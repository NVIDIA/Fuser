# NvFuser Serialization

Serde is an acronym of serialization and deserialization.

# Flatbuffers
**Command:** The cpp header is autogenerated from the schema file using `flatc`.

`flatc --cpp python_fusion_cache.fbs`

**Command:** Convert flatbuffer binary to human-readable JSON file.

`flatc --json --raw-binary python_fusion_cache.fbs -- [your_fc_serde_file].bin`

References:
1. https://google.github.io/flatbuffers/flatbuffers_guide_use_cpp.html
2. https://google.github.io/flatbuffers/flatbuffers_guide_writing_schema.html

# Serde Interface

In test_python_frontend.py, the `exec_nvfuser` function is decorated with the `serde_check` functions. Every unit test should automatically test serialization.

```python
def serde_check(fucion_func: Callable, *args):
    # Deep copy inputs because when a fusion output aliases an input, 
    # it will change the input value for the subsequent function calls.
    args_copy = deepcopy(args)

    # For debug purposes, clear FusionCache before running first test
    FusionCache.reset()

    # Run test to populate FusionCache
    test_fn(fusion, *args, **kwargs)

    # Serialize FusionCache
    fc = FusionCache.get()
    fc.serialize("foo.bin")

    FusionCache.reset()

    # Get new FusionCache because the previous one was destroyed by the reset call.
    fc = FusionCache.get()
    fc.deserialize("foo.bin")

    # Run test with repopulated FusionCache
    return test_fn(fusion_func, args_copy)
```

# Python Frontend Example

```python
def fusion(fd: FusionDefinition):
    t0 = fd.define_tensor(symbolic_sizes=[-1, -1], contiguity=[True, True])
    c0 = fd.define_constant(1.0, DataType.Float)
    t1 = fd.ops.full(size=[-1, -1], arg=c0, dtype=DataType.Float)
    t2 = fd.ops.add(t0, t1)
    fd.add_output(t2)

# Corresponding FusionCache Trie Structure

1. StartRecord
2. TensorRecord --- t0
3. ScalarRecord --- c0
3. FullOpRecord --- t1
4. OpRecord<TensorView*, TensorView*, TensorView*> --- t2
4. OutputRecord
5. EndRecord
```
# Serialization Overview

## FusionCache
Here are the main data members of the `FusionCache` and `TrieNode`.

```cpp
class FusionCache {
private:
  //! The max allowed number of fusions in the cache
  size_t max_fusions_;

  //! The root (start) of the prefix tree to start a cache look up of a given
  //! fusion definition.
  std::unique_ptr<TrieNode> root_;

  //! A vector of nvFuser Fusion IR fusions.
  std::vector<FusionSchedules> fusions_;

  //! A vector of Terminal trie nodes for Stats collection
  std::vector<TrieNode*> terminal_nodes_;
};

struct TrieNode {
  std::unique_ptr<RecordFunctor> record;

  //! A hash map of the children for the current node.
  //! The hash map hashes a pointer to a RecordFunctor because
  //! the hash function is virtual.
  std::unordered_map<RecordFunctor*, std::unique_ptr<TrieNode>> children;

  //! An index into FusionCache's vector of nvFuser object that holds an
  //! unscheduled Fusion.  The id is only valid if the entry is terminal.
  size_t fusion_id;

  //! Count of times the Entry is traversed
  size_t visits;
};
```

Before seralizing the FusionCache, we flatten the Trie into a vector using breadth-first search (BFS).
Given the BFS ordering, we serialize the `TrieNode` and map the terminal node pointers to their 
corresponding BFS position. 

**Implementation Note:** We cannot build nested Flatbuffer objects at the same time.
e.g., All Flatbuffer objects MUST be created before the start of the table they are referenced

Here are the corresponding Flatbuffer tables for the `FusionCache` and `TrieNode`:
```
table FusionCache:
- max_fusions : ulong
- structure : [TrieNode]
- terminal_nodes : [ulong]

table TrieNode:
- record : RecordFunctor
- children : [ulong]
- fusion_id : ulong
- visits: ulong
```

## RecordFunctor

```
table RecordFunctor:
- args: [State]
- outputs: [State]
- name: string
- type: RecordType -> An enum that specifies the RecordType for the RecordFunctor.
- data: RecordData -> A union that holds the data specific for the RecordFunctor.
```

## How to add a new RecordFunctor?
The args, outputs, and name fields are defined by all RecordFunctor tables. They are handled by

```cpp
flatbuffers::Offset<serde::RecordFunctor> RecordFunctor::serialize(flatbuffers::FlatBufferBuilder& builder)
```

Some RecordFunctor tables require extra information, so we define the `RecordData` union. In Flatbuffers, a `Union` field can hold a reference to any of those types.

In this example, the `RecordData` field only defines basic data types.
```
union RecordData {
    Bool,
    ComplexDouble,
    Double,
    Int,
}
```

We want to store the attributes of the `FullOpRecord` that holds `std::vector<int64_t> shape` and `PrimDataType dtype`.

1. Add `TensorCreation` table to `python_fusion_cache.fbs`
```
// Data for FullOpRecord
// The shape is defined with constant numbers.
table TensorCreation {
    shape: [long];
    dtype: DataType;
}
```

2. Add `TensorCreation` table to `RecordData` union.
3. Define virtual function `recordData` in `FullOpRecord` to create `TensorCreation` object.

```cpp
  virtual std::pair<serde::RecordData, flatbuffers::Offset<void>> recordData(
      flatbuffers::FlatBufferBuilder& builder) const final {
    auto tensor_creation_data = serde::CreateTensorCreationDirect(builder, &shape_, mapToSerdeDtype(dtype_);
    return {serde::RecordData_TensorCreation, tensor_creation_data.Union()};
  }
```
**Implementation Note:** After creating the `TensorCreation` object, we call `Union` to return a generic object `flatbuffers::Offset<void>`.

# Deserialization Overview

## FusionCache
We traverse the structure field of the `FusionCache` table in BFS order.
During the traversal, we rebuild Trie and the `FusionState` objects.
Upon reaching a terminal node, we construct a new cpp `Fusion` using the `FusionState`.

```cpp
struct BfsState {
    TrieNode* ptr;
    size_t structure_idx;
    FusionState* state;
};

while (!queue.empty()) {
    BfsState current = queue.pop_front();
    Flatbuffer* trie_node = getNode(current->structure_idx);

    // Add current RecordFunctor to its FusionState
    
    if trie_node->is_terminal {
        // Build cpp Fusion using FusionState
    }

    for (auto child_structure_idx : current->children) {
        Flatbuffer* child_trie_node = getNode(child_structure_idx);
        // Construct its RecordFunctor and TrieNode
        // Add child's (RecordFunctor, TrieNode) to the parent's children map
        // Clone the parent's FusionState
        // Add child's BfsState to queue
    }
}
``` 

## RecordFunctorFactory
The `RecordFunctorFactory` maps each RecordType enum value to a function that creates the corresponding `RecordFunctor`. 

**Implentation Notes:**
- We converted the RecordType enum to a Flatbuffer Enum field. 
- Expand RecordType enum to describe template arguments at runtime.

RecordType Examples:
| RecordType Enum  | std::function |
| ------------- | ------------- |
| Unary_TV | `TV* (*) (TV*)` |
| Binary_TV_VAL | `TV* (*) (TV*, VAL*)` |
| Ternary_TV_VAL_TV | `TV* (*) (TV*, VAL*, TV*)` |
| Ternary_Alpha_TV_TV_VAL | `TV* (*) (TV*, TV*, VAL*, VAL*)` |

## How to add a new RecordFunctor parser function?
1. Add `registerParser` function to `void RecordFunctorFactory::registerAllParsers()` that maps `RecordType` to the parser function.
2. Create parser function.

```cpp
typedef std::function<BaseType*(const SerdeBuffer*)> SerdeParser;
// where the BaseType is nvfuser::RecordFunctor and SerdeBuffer is serde::RecordFunctor.
```

**Implementation Note:** Use a lambda if you need additional arguments in your parser function.


## How to add a new OpRecord parser function?
- Add `{std::string, std::function}` to `void RecordFunctorFactory::setupFunctionMaps()` by applying appropriate macro `NVFUSER_BINARY_TV_OP(str, nvfuser_fn)`
- E.g., Add `ops.sub` to `RecordFunctorFactory` with `NVFUSER_BINARY_TV_OP("sub", sub)`
- The macro updates all of the `str_to_func_map` associated with the operator.

```cpp
typedef std::function<TensorView*(TensorView*, TensorView*)> binary_tv_fn;
typedef std::function<Val*(Val*, Val*)> binary_val_fn;
typedef std::function<TensorView*(TensorView*, Val*)> binary_tv_val_fn;
typedef std::function<TensorView*(Val*, TensorView*)> binary_val_tv_fn;

// Binary Functions
std::unordered_map<std::string, binary_tv_fn> binary_tv;
std::unordered_map<std::string, binary_val_fn> binary_val;
std::unordered_map<std::string, binary_tv_val_fn> binary_tv_val;
std::unordered_map<std::string, binary_val_tv_fn> binary_val_tv;
```

## Example 1 - FullOpRecord
Here is the Flatbuffer schema for `FullOpRecord`.

```
table RecordFunctor:
- args: [c0]
- outputs: [t1]
- name: "ops.full"
- type: serde::RecordType_FullOp
- data: [size=[-1, -1], dtype=DataType.Float]
```

Here is the registered parser for the `FullOpRecord` RecordFunctor.

```cpp
registerParser(serde::RecordType_FullOp, deserializeFullRecord);
```

Here is the parser function.

**Implementation Note:** We convert the generic `RecordFunctor` buffer back to the specific `TensorCreation` field.

```cpp
RecordFunctor* deserializeFullRecord(const serde::RecordFunctor* buffer) {
  auto data = buffer->data_as_TensorCreation();
  return new FullOpRecord(
      parseStateArgs(buffer->args()),
      parseStateArgs(buffer->outputs()),
      parseVector(data->shape()),
      mapToNvfuserDtype(data->dtype()));
}
```

## Example 2 - OpRecord - Add

Here is the Flatbuffer schema for `Add - OpRecord`.
```
table RecordFunctor:
- args: [t0, t1]
- outputs: [t2]
- name: "ops.add"
- type: serde::RecordType_Binary_TV_VAL
```

Here is the registered parser for the `OpRecord<TensorView*, TensorView*, TensorView*>` RecordFunctor.

```cpp
// Binary Ops
auto binary_tv_parser = [&](const serde::RecordFunctor* buffer) {
  return deserializeOpRecord<
    binary_tv_fn,
    TensorView*,
    TensorView*,
    TensorView*>(binary_tv, serde::RecordType_Binary_TV, buffer);
};
registerParser(serde::RecordType_Binary_TV, binary_tv_parser);
```

Here is the parser function, which is the same for all `OpRecord` objects.

**Implementation Notes:** 
1. Use `std::string` name to map to NvFuser operations.
2. Since all functions in the factory have the same signature, we support additional arguments using lambdas.

```cpp
template <class fn_type, class... Signature>
RecordFunctor* deserializeOpRecord(
    const std::unordered_map<std::string, fn_type>& str_to_func_map,
    serde::RecordType record_type,
    const serde::RecordFunctor* buffer) {
  return new OpRecord<Signature...>(
      parseStateArgs(buffer->args()),
      parseStateArgs(buffer->outputs()),
      buffer->name()->str(),
      record_type,
      str_to_func_map.at(buffer->name()->str()));
}
```

Run `NVFUSER_BINARY_TV_OP("add", add)` macro in `RecordFunctorFactory::setupFunctionMaps` to insert the operation.
