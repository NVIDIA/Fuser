# NvFuser Serialization

Serde is an acronym of serialization and deserialization.

# Overview

### Python Frontend
* `FusionSchedules` are stored in the `FusionCache`. The `FusionCache` is a Trie structure.
Intermediate nodes in the Trie correspond with individual operations in the Fusion.
Only the terminal nodes contain a `FusionSchedules` object, which has a complete `Fusion` and `FusionExecutorCache`.

### FusionExecutorCache
* `FusionExecutorCache` maps an unscheduled fusion to a specific set of compiled kernels given a gpu device id and dynamic shapes concretization info.
* It contains an `InputsIdLookup` instance, which encodes the fusion's input arguments as a string and places it in a LRU cache.
The string's position in the cache becomes the input's cache id.
* In the `kernel_runtimes_` unordered_map, there is a vector of `FusionKernelRuntime` objects for each `device_id` and `concrete_info` pair key.
* Storing multiple `FusionKernelRuntime` objects allows for better performance by matching scheduler heuristics.

#### Serialization:
* The unordered_map is transformed into a vector of `KernelRuntimeState` tables.
This table represents a key-value pair in the unordered_map.

### FusionKernelRuntime
* `FusionKernelRuntime` contains the segments for a Fusion. Each segment is represented by a `FusionExecutor` object.

#### Serialization:
* We save a metadata copy of the arguments used to construct the `FusionKernelRuntime`. During deserialization,
we call the constructor using the saved metadata arguments. Afterwards, we regenerate the `FusionExecutor` objects,
which are normally built by calling `compileFusionParallel` outside the constructor.

### KernelArgumentHolder
* A collection of `PolymorphicValue` objects representing Scalars [`int, double, bool, complex`], Cpu Scalars, and Gpu Tensors.
* **Note:** Pointer address of meta aten tensors is zero. The pointer address is used to specify vectorization during schedule.

### FusionExecutor
* `FusionExecutor` defines two data structs: `ExecutorEntry` and `GlobalBufferInfo`
* `ExecutorEntry` contains information to launch a kernel for a set of input arguments. It contains the launch parameters,
output-to-input alias map, and global buffer configurations.
* `GlobalBufferInfo` specifies the buffer's tensor properties [`shape, stride, dtype`] and its corresponding TensorView.

#### Serialization:
* TensorView pointers are encoded as integer positions in a vector. The assumption is that the information is consistent after deserialization.
* For `output` buffers, we use the position in `fusion->outputs()` vector.
* For `intermediate` buffers, we use the position in `kernel->summary().global_allocations` vector.
* Deserializing `GlobalBufferInfo` requires lowering kernel first because it uses `KernelSummary.`
* KernelDB query function uses `kernel_code_` string and `CompileParams` to select desired cubin.

# Flatbuffers
**Command:** The cpp header is autogenerated from the schema file using `flatc`.

`flatc --cpp fusion_cache.fbs`

**Command:** Convert flatbuffer binary to human-readable JSON file.

`flatc --json --raw-binary csrc/serde/fusion_cache.fbs -- [your_fc_serde_file].bin`

References:
1. https://google.github.io/flatbuffers/flatbuffers_guide_use_cpp.html
2. https://google.github.io/flatbuffers/flatbuffers_guide_writing_schema.html

# Serde Testing

In test_python_frontend.py, the `exec_nvfuser` function is decorated with the `serde_check` functions. Every unit test should automatically test serialization.

```python
def serde_check(test_fn: Callable):
    """
    A decorator to verify that serialization works with the given exec_nvfuser function.
    It uses serialization to rebuild the FusionCache structure.
    """

    def inner(*args, **kwargs):
        self, fusion_func, inputs = args
        # Deep copy inputs because when a fusion output aliases an input, it will change the input value for the
        # subsequent function calls.
        inputs_copy = deepcopy(inputs)

        # skip_serde_check is only used by the decorator so remove it before running test_fn
        skip_serde_check = kwargs.pop("skip_serde_check", False)

        # Run test to populate FusionCache
        result = test_fn(*args, **kwargs)

        if skip_serde_check:
            return result

        with tempfile.NamedTemporaryFile() as tmp:
            # Serialize FusionCache
            fc = FusionCache.get()
            fc.serialize(tmp.name)

            FusionCache.reset()

            # Get new FusionCache because the previous one was destroyed by the reset call.
            fc = FusionCache.get()
            fc.deserialize(tmp.name)

        # Run test with repopulated FusionCache
        kwargs["new_fusion_expected"] = False
        return test_fn(self, fusion_func, inputs_copy, **kwargs)

    return inner
```

# Python Frontend Example

```python
def fusion(fd: FusionDefinition):
    t0 = fd.define_tensor(shape=[-1, -1], contiguity=[True, True])
    c0 = fd.define_scalar(1.0, DataType.Float)
    t1 = fd.ops.full(size=[-1, -1], arg=c0, dtype=DataType.Float)
    t2 = fd.ops.add(t0, t1)
    fd.add_output(t2)

# Corresponding FusionCache Trie Structure

1. StartRecord
2. TensorRecord --- t0
3. ScalarRecord --- c0
3. FullOpRecord --- t1
4. OpRecord<TensorView*, TensorView*, TensorView*> --- t2
4. OutputRecord
5. EndRecord
```
# Serialization Overview

## FusionCache
Here are the main data members of the `FusionCache` and `TrieNode`.

```cpp
class FusionCache {
private:
  //! The max allowed number of fusions in the cache
  size_t max_fusions_;

  //! The root (start) of the prefix tree to start a cache look up of a given
  //! fusion definition.
  std::unique_ptr<TrieNode> root_;

  //! A vector of nvFuser Fusion IR fusions.
  std::vector<FusionSchedules> fusions_;

  //! A vector of Terminal trie nodes for Stats collection
  std::vector<TrieNode*> terminal_nodes_;

  //! A vector of nvFuser Fusion IR fusions.
  std::vector<std::unique_ptr<FusionSchedules>> fusions_;
};

struct TrieNode {
  std::unique_ptr<RecordFunctor> record;

  //! A hash map of the children for the current node.
  //! The hash map hashes a pointer to a RecordFunctor because
  //! the hash function is virtual.
  std::unordered_map<RecordFunctor*, std::unique_ptr<TrieNode>> children;

  //! An index into FusionCache's vector of nvFuser object that holds an
  //! unscheduled Fusion.  The id is only valid if the entry is terminal.
  size_t fusion_id;

  //! Count of times the Entry is traversed
  size_t visits;
};
```

Before seralizing the FusionCache, we flatten the Trie into a vector using breadth-first search (BFS).
Given the BFS ordering, we serialize the `TrieNode` and map the terminal node pointers to their 
corresponding BFS position. 

**Implementation Note:** We cannot build nested Flatbuffer objects at the same time.
e.g., All Flatbuffer objects MUST be created before the start of the table they are referenced

Here are the corresponding Flatbuffer tables for the `FusionCache` and `TrieNode`:
```
table FusionCache:
- max_fusions : ulong
- structure : [TrieNode]
- terminal_nodes : [ulong]
- auto_gen_schedules : [FusionExecutorCache];

table TrieNode:
- record : RecordFunctor
- children : [ulong]
- fusion_id : ulong
- visits: ulong
- is_terminal: bool;
```

## RecordFunctor

```
table RecordFunctor:
- args: [State]
- outputs: [State]
- name: string
- type: RecordType -> An enum that specifies the RecordType for the RecordFunctor.
- data: RecordData -> A union that holds the data specific for the RecordFunctor.
```

## How to add a new RecordFunctor?
The args, outputs, and name fields are defined by all RecordFunctor tables. They are handled by

```cpp
flatbuffers::Offset<serde::RecordFunctor> RecordFunctor::serialize(flatbuffers::FlatBufferBuilder& builder)
```

Some RecordFunctor tables require extra information, so we define the `RecordData` union. In Flatbuffers, a `Union` field can hold a reference to any of those types.

In this example, the `RecordData` field only defines basic data types.
```
union RecordData {
    Bool,
    ComplexDouble,
    Double,
    Int,
}
```

We want to store the attributes of the `FullOpRecord` that holds `std::vector<int64_t> shape` and `PrimDataType dtype`.

1. Add `TensorCreation` table to `python_fusion_cache.fbs`
```
// Data for FullOpRecord
// The shape is defined with constant numbers.
table TensorCreation {
    shape: [long];
    dtype: DataType;
}
```

2. Add `TensorCreation` table to `RecordData` union.
3. Define virtual function `recordData` in `FullOpRecord` to create `TensorCreation` object.

```cpp
  virtual std::pair<serde::RecordData, flatbuffers::Offset<void>> recordData(
      flatbuffers::FlatBufferBuilder& builder) const final {
    auto tensor_creation_data =
      serde::CreateTensorCreationDirect(builder, &shape_, nvfuser::toUnderlying(dtype_);
    return {serde::RecordData_TensorCreation, tensor_creation_data.Union()};
  }
```
**Implementation Note:** After creating the `TensorCreation` object, we call `Union` to return a generic object `flatbuffers::Offset<void>`.

# Deserialization Overview

## FusionCache
We traverse the structure field of the `FusionCache` table in BFS order.
During the traversal, we rebuild Trie and the `FusionState` objects.
Upon reaching a terminal node, we construct a new cpp `Fusion` using the `FusionState`.

```cpp
using BfsState = std::pair<TrieNode*, size_t>;

// bfs_order is used to map indices in the structure field to their
// corresponding TrieNode pointers. It is used to reconstruct the
// terminal_nodes vector.
std::vector<TrieNode*> bfs_order;

while (!queue.empty()) {
    BfsState current = queue.pop_front();
    Flatbuffer* trie_node = getNode(current->structure_idx);

    // Add trie_node to bfs_order
    // Add current RecordFunctor to its FusionState
    
    if (trie_node->is_terminal()) {
        // Build cpp Fusion using FusionState
    }

    for (auto child_structure_idx : current->children) {
        Flatbuffer* child_trie_node = getNode(child_structure_idx);
        // Construct its RecordFunctor and TrieNode
        // Add child's (RecordFunctor, TrieNode) to the parent's children map
        // Clone the parent's FusionState
        // Add child's BfsState to queue
    }
}

// Deserialize terminal_nodes field in the FusionCache table
for (auto idx : c10::irange(fusions_.size())) {
  // Add trie_node from bfs_order to terminal_nodes_
  // Get FusionExecutorCache for terminal TrieNode
  // Deserialize FusionExecutorCache
}
``` 

## RecordFunctorFactory
The `RecordFunctorFactory` maps each RecordType enum value to a function that creates the corresponding `RecordFunctor`. 

**Implentation Notes:**
- We converted the RecordType enum to a Flatbuffer Enum field. 
- Expand RecordType enum to describe template arguments at runtime.

RecordType Examples:
| RecordType Enum  | std::function |
| ------------- | ------------- |
| Unary_TV | `TV* (*) (TV*)` |
| Binary_TV_VAL | `TV* (*) (TV*, VAL*)` |
| Ternary_TV_VAL_TV | `TV* (*) (TV*, VAL*, TV*)` |
| Ternary_Alpha_TV_TV_VAL | `TV* (*) (TV*, TV*, VAL*, VAL*)` |

## How to add a new RecordFunctor parser function?
1. Add `registerParser` function to `void RecordFunctorFactory::registerAllParsers()` that maps `RecordType` to the parser function.
2. Create parser function.

```cpp
typedef std::function<BaseType*(const SerdeBuffer*)> SerdeParser;
// where the BaseType is nvfuser::RecordFunctor and SerdeBuffer is serde::RecordFunctor.
```

**Implementation Note:** Use a lambda if you need additional arguments in your parser function.


## How to add a new OpRecord parser function?
- Add `{std::string, std::function}` to `void RecordFunctorFactory::setupFunctionMaps()` by applying appropriate macro `NVFUSER_BINARY_TV_OP(str, nvfuser_fn)`
- E.g., Add `ops.sub` to `RecordFunctorFactory` with `NVFUSER_BINARY_TV_OP("sub", sub)`
- The macro updates all of the `str_to_func_map` associated with the operator.

```cpp
typedef std::function<TensorView*(TensorView*, TensorView*)> binary_tv_fn;
typedef std::function<Val*(Val*, Val*)> binary_val_fn;
typedef std::function<TensorView*(TensorView*, Val*)> binary_tv_val_fn;
typedef std::function<TensorView*(Val*, TensorView*)> binary_val_tv_fn;

// Binary Functions
std::unordered_map<std::string, binary_tv_fn> binary_tv;
std::unordered_map<std::string, binary_val_fn> binary_val;
std::unordered_map<std::string, binary_tv_val_fn> binary_tv_val;
std::unordered_map<std::string, binary_val_tv_fn> binary_val_tv;
```

## Example 1 - FullOpRecord
Here is the Flatbuffer schema for `FullOpRecord`.

```
table RecordFunctor:
- args: [c0]
- outputs: [t1]
- name: "ops.full"
- type: serde::RecordType_FullOp
- data: [size=[-1, -1], dtype=DataType.Float]
```

Here is the registered parser for the `FullOpRecord` RecordFunctor.

```cpp
registerParser(serde::RecordType_FullOp, deserializeFullRecord);
```

Here is the parser function.

**Implementation Note:** We convert the generic `RecordFunctor` buffer back to the specific `TensorCreation` field.

```cpp
RecordFunctor* deserializeFullRecord(const serde::RecordFunctor* buffer) {
  auto data = buffer->data_as_TensorCreation();
  return new FullOpRecord(
      parseStateArgs(buffer->args()),
      parseStateArgs(buffer->outputs()),
      parseVector(data->shape()),
      mapToNvfuserDtype(data->dtype()));
}
```

## Example 2 - OpRecord - Add

Here is the Flatbuffer schema for `Add - OpRecord`.
```
table RecordFunctor:
- args: [t0, t1]
- outputs: [t2]
- name: "ops.add"
- type: serde::RecordType_Binary_TV_VAL
```

Here is the registered parser for the `OpRecord<TensorView*, TensorView*, TensorView*>` RecordFunctor.

```cpp
// Binary Ops
auto binary_tv_parser = [&](const serde::RecordFunctor* buffer) {
  return deserializeOpRecord<
    binary_tv_fn,
    TensorView*,
    TensorView*,
    TensorView*>(binary_tv, serde::RecordType_Binary_TV, buffer);
};
registerParser(serde::RecordType_Binary_TV, binary_tv_parser);
```

Here is the parser function, which is the same for all `OpRecord` objects.

**Implementation Notes:** 
1. Use `std::string` name to map to NvFuser operations.
2. Since all functions in the factory have the same signature, we support additional arguments using lambdas.

```cpp
template <class fn_type, class... Signature>
RecordFunctor* deserializeOpRecord(
    const std::unordered_map<std::string, fn_type>& str_to_func_map,
    serde::RecordType record_type,
    const serde::RecordFunctor* buffer) {
  return new OpRecord<Signature...>(
      parseStateArgs(buffer->args()),
      parseStateArgs(buffer->outputs()),
      buffer->name()->str(),
      record_type,
      str_to_func_map.at(buffer->name()->str()));
}
```

Run `NVFUSER_BINARY_TV_OP("add", add)` macro in `RecordFunctorFactory::setupFunctionMaps` to insert the operation.
