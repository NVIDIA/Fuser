// clang-format off
/*
 * SPDX-FileCopyrightText: Copyright (c) 2025-present NVIDIA CORPORATION & AFFILIATES.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 */
// clang-format on
#include <fusion.h>
#include <hash.h>
#include <utils.h>

namespace nvfuser {

size_t hash(Fusion* fusion) {
  size_t hash = 0;

  // Gather all expressions in CPP Fusion.
  std::vector<Expr*> exprs = fusion->exprs();
  std::deque<Expr*> to_visit(exprs.begin(), exprs.end());

  // Topological search of Fusion expressions
  size_t skip_count = 0;
  std::unordered_set<Expr*> visited;
  std::unordered_set<const Val*> visited_vals;

  for (const auto& val : fusion->inputs()) {
    std::cout << "Input: " << val->toString() << std::endl;
    hashCombine(hash, val->hash());
    visited_vals.insert(val);
  }

  while (!to_visit.empty()) {
    Expr* e = to_visit.front();
    NVF_ERROR(e != nullptr, "Expression is nullptr");
    to_visit.pop_front();

    NVF_ERROR(
        skip_count <= to_visit.size(),
        "Cycle detected: None of the expressions can be processed!");

    // short-circuit: skip if already visited
    if (visited.count(e) > 0) {
      continue;
    }

    // Handle scalars and constants not generated by separate expression.
    std::vector<Val*> scalars;
    std::copy_if(
        e->inputs().begin(),
        e->inputs().end(),
        std::back_inserter(scalars),
        [](Val* v) { return v->isScalar(); });
    for (const Val* val : scalars) {
      std::cout << "Scalar: " << val->toString() << std::endl;
      hashCombine(hash, val->hash());
      visited_vals.insert(val);
    }

    // short-circuit: add to back of stack if not all of the expression's
    // dependencies are satisfied.
    bool all_dependencies_satisfied =
        std::all_of(e->inputs().begin(), e->inputs().end(), [&](const Val* v) {
          return visited_vals.count(v) > 0;
        });
    if (!all_dependencies_satisfied) {
      ++skip_count;
      to_visit.push_back(e);
      continue;
    }

    // Create string representation given inputs, outputs, and attributes.
    visited.insert(e);
    std::cout << "Expr: " << e->toString() << std::endl;
    hashCombine(hash, e->hash());
    visited_vals.insert(e->outputs().begin(), e->outputs().end());
    skip_count = 0;
  }

  std::cout << "Outputs: " << fusion->outputs().size() << std::endl;
  for (nvfuser::Val* val : fusion->outputs()) {
    hashCombine(hash, val->hash());
  }
  return hash;
}

} // namespace nvfuser
