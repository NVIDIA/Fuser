// clang-format off
/*
 * SPDX-FileCopyrightText: Copyright (c) 2025-present NVIDIA CORPORATION & AFFILIATES.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 */
// clang-format on

#include <scheduler/tools/cub_utils.h>
#include <utils.h>

namespace nvfuser {
namespace scheduler_tools {

namespace {
/*
 CUB BlockRadixSort shared memory usage (Generated by Cursor with GPT-5)

 Assumptions:
 - RADIX_BITS = 4 (RADIX_DIGITS = 16)
 - SMEM bank size = 4 bytes
 - INNER_SCAN_ALGORITHM = BLOCK_SCAN_WARP_SCANS
 - align32(x) rounds x up to the next multiple of 32 bytes: ((x + 31) & ~31)

 Composition:
 - BlockRadixSort::TempStorage is a union of:
   AscendingBlockRadixRank::TempStorage,
   DescendingBlockRadixRank::TempStorage,
   BlockExchange<KeyT>::TempStorage,
   BlockExchange<ValueT>::TempStorage.
 - Total bytes: S(BlockRadixSort) = max(S_rank, S_exch(KeyT), S_exch(ValueT)).

 Rank storage (independent of KeyT/ValueT):
 - Let B = BLOCK_DIM_X x BLOCK_DIM_Y x BLOCK_DIM_Z, W = ceil(B / 32).
 - PackedCounter = unsigned int (4 bytes) for 4-byte SMEM banks.
 - Aliasable part (digit counters or raking grid): S_rank_aliasable = 36 * B
 bytes  // RADIX_BITS=4 => PADDED_COUNTER_LANES=9
 - BlockScan contribution:
     * If (B % 32 == 0)  // warp-scans path
         S_blockscan ~= align32(4 * W + 4) bytes
       (only W warp aggregates + one block prefix; per-warp TempStorage is empty
 due to SHFL)
     * Else               // raking fallback
         S_blockscan is larger (~1 KB near B~200). Exact size depends on
 BlockRakingLayout and alignment.
 - Total: S_rank = S_rank_aliasable + S_blockscan.

 Exchange storage (depends on KeyT/ValueT):
 - TILE_ITEMS = B * ITEMS_PER_THREAD
 - PADDING_ITEMS = (ITEMS_PER_THREAD > 4 && power_of_two(ITEMS_PER_THREAD)) ?
 (TILE_ITEMS >> 5) : 0  // 32 banks
 - S_exch(T) = sizeof(T) * (TILE_ITEMS + PADDING_ITEMS)

 Worked examples (KeyT = int64_t, ValueT = int64_t, BLOCK_DIM_Y = BLOCK_DIM_Z =
 1, RADIX_BITS = 4, SMEM banks = 4B):

 ITEMS_PER_THREAD = 1
 - B = 128 (W = 4):   S_rank = 36*128 + align32(4*4 + 4) = 4608 + 32 = 4640
                       S_exch(key)=8*128=1024, values=1024 -> S = 4640
 - B = 224 (W = 7):   S_rank = 36*224 + align32(4*7 + 4) = 8064 + 32 = 8096
                       S = 8096
 - B = 256 (W = 8):   S_rank = 36*256 + align32(4*8 + 4) = 9216 + 64 = 9280
                       S = 9280
 - B = 200 (W = 7, raking): S_rank = 36*200 + 1024 = 8224 (exact)
                             S = 8224

 ITEMS_PER_THREAD = 4  (no padding)
 - B = 128: S = 4640
 - B = 224: S = 8096
 - B = 256: S = 9280
 - B = 200: S = 8224

 ITEMS_PER_THREAD = 8  (padding applies; PADDING_ITEMS = (B*8)/32 = B/4)
 - B = 128: S_rank = 4640; S_exch(T) = 8*(128*8 + 32) = 8448 -> S = 8448
 - B = 224: S_rank = 8096; S_exch(T) = 8*(224*8 + 56) = 14784 -> S = 14784
 - B = 256: S_rank = 9280; S_exch(T) = 8*(256*8 + 64) = 16896 -> S = 16896
 - B = 200: S_rank = 8224; S_exch(T) = 8*(200*8 + 50) = 13200 -> S = 13200
*/

constexpr int64_t alignUp(int64_t value, int64_t alignment) {
  return (value + (alignment - 1)) & ~(alignment - 1);
}

constexpr int64_t ceilDiv(int64_t a, int64_t b) {
  return (a + b - 1) / b;
}

constexpr bool isPowerOfTwo(int64_t x) {
  return x != 0 && (x & (x - 1)) == 0;
}

constexpr int64_t ceilLog2(int64_t x) {
  // returns ceil(log2(x)) for x >= 1
  int64_t n = 0;
  int64_t v = 1;
  while (v < x) {
    v <<= 1;
    ++n;
  }
  return n;
}

constexpr int64_t computeBlockRadixSortTempStorageBytes(
    int64_t block_threads,
    int64_t items_per_thread,
    int64_t key_size_bytes,
    int64_t value_size_bytes) {
  // Rank aliasable part (RADIX_BITS=4, 4B banks → PADDED_COUNTER_LANES=9 → 36
  // bytes per thread)
  const int64_t rank_aliasable_bytes = int64_t{36} * block_threads;

  // BlockScan contribution inside BlockRadixRank
  const bool multiples_of_32 = (block_threads % int64_t{32}) == 0;
  const int64_t warps = ceilDiv(block_threads, int64_t{32});

  int64_t blockscan_bytes = 0;
  if (multiples_of_32) {
    // Warp-scans path: W warp aggregates (4B each) + W bytes for array of empty
    // per-warp TempStorage + one block prefix (4B), aligned to 32 bytes
    const int64_t raw = int64_t{5} * warps + int64_t{4};
    blockscan_bytes = alignUp(raw, int64_t{32});
  } else {
    // Raking path: compute exact size using BlockRakingLayout and WarpScanSmem
    // for PackedCounter (4B)
    const int64_t max_raking_threads =
        block_threads < int64_t{32} ? block_threads : int64_t{32};
    const int64_t segment_length = ceilDiv(block_threads, max_raking_threads);
    const bool use_segment_padding =
        ((segment_length & int64_t{1}) == 0) && (segment_length > int64_t{2});
    const int64_t raking_threads = ceilDiv(block_threads, segment_length);

    // WarpScan storage: shfl variant for power-of-two raking_threads (empty),
    // smem variant otherwise (1.5 * raking_threads elements of 4B)
    int64_t warp_scan_size = 0;
    if (isPowerOfTwo(raking_threads)) {
      // Empty TempStorage still contributes 1 byte as a member
      warp_scan_size = 1;
    } else {
      const int64_t steps = ceilLog2(raking_threads);
      const int64_t half_warp_threads =
          (steps == 0) ? int64_t{0} : (int64_t{1} << (steps - 1));
      const int64_t warp_smem_elements = raking_threads + half_warp_threads;
      warp_scan_size =
          int64_t{4} * warp_smem_elements; // sizeof(PackedCounter)=4
    }

    // BlockRakingLayout grid
    const int64_t grid_elements = raking_threads *
        (segment_length + (use_segment_padding ? int64_t{1} : int64_t{0}));
    const int64_t raking_grid_bytes =
        int64_t{4} * grid_elements; // sizeof(PackedCounter)=4

    // Layout with alignments: warp_scan (4B aligned) -> pad to 16B ->
    // raking_grid (align 16) -> block_aggregate (4B)
    int64_t total = 0;
    total += warp_scan_size;
    total = alignUp(total, int64_t{16});
    total += alignUp(raking_grid_bytes, int64_t{16});
    total += int64_t{4}; // block_aggregate of PackedCounter
    total = alignUp(total, int64_t{16}); // struct alignment

    blockscan_bytes = total;
  }

  const int64_t rank_bytes = rank_aliasable_bytes + blockscan_bytes;

  // Exchange storage for key/value types
  const int64_t tile_items = block_threads * items_per_thread;
  const bool needs_padding =
      (items_per_thread > int64_t{4}) && isPowerOfTwo(items_per_thread);
  const int64_t padding_items = needs_padding
      ? (tile_items >> int64_t{5})
      : int64_t{0}; // 32 banks → LOG_SMEM_BANKS=5
  const int64_t exchange_keys = key_size_bytes * (tile_items + padding_items);
  const int64_t exchange_values =
      value_size_bytes * (tile_items + padding_items);
  int64_t exchange_bytes =
      exchange_keys > exchange_values ? exchange_keys : exchange_values;
  // BlockExchange::_TempStorage is alignas(16), so size is rounded up to
  // 16-byte multiple
  exchange_bytes = alignUp(exchange_bytes, int64_t{16});

  // Exchange buffers are in a union; contribution is the larger of the two. For
  // keys-only, set value_size_bytes=0.
  int64_t result = rank_bytes > exchange_bytes ? rank_bytes : exchange_bytes;
  // The union holding rank/exchange storage inherits max alignment (16 via
  // BlockExchange), so the final size rounds up to 16 bytes.
  result = alignUp(result, int64_t{16});
  return result;
}

} // namespace

void CubSharedMemoryBuffer::registerArgsort(
    int64_t bdimx,
    int64_t items_per_thread,
    DataType dtype) {
  max_bdimx_ = std::max(max_bdimx_, bdimx);
  argsort_calls_.emplace(items_per_thread, dtype);
}

void CubSharedMemoryBuffer::registerTopK(
    int64_t bdimx,
    int64_t items_per_thread,
    DataType dtype) {
  max_bdimx_ = std::max(max_bdimx_, bdimx);
  topk_calls_.emplace(items_per_thread, dtype);
}

int64_t CubSharedMemoryBuffer::getArgsortTotalSizeInBytes() const {
  int64_t total_size = 0;
  for (const auto& template_instance : argsort_calls_) {
    total_size += computeBlockRadixSortTempStorageBytes(
        max_bdimx_,
        template_instance.items_per_thread,
        dataTypeSizeByte(template_instance.dtype),
        sizeof(int64_t));
  }

  return total_size;
}

int64_t CubSharedMemoryBuffer::getTopKTotalSizeInBytes() const {
  int64_t total_size = 0;
  for (const auto& template_instance : topk_calls_) {
    total_size += computeBlockRadixSortTempStorageBytes(
        max_bdimx_,
        template_instance.items_per_thread,
        dataTypeSizeByte(template_instance.dtype),
        sizeof(int64_t));
  }

  return total_size;
}

int64_t CubSharedMemoryBuffer::getTotalSizeInBytes() const {
  return getArgsortTotalSizeInBytes() + getTopKTotalSizeInBytes();
}

} // namespace scheduler_tools
} // namespace nvfuser
