#!/usr/bin/env python3
"""
nvFuser Dependency Report Generator

Reads dependency data from JSON (generated by CMake) and prints
a comprehensive, user-friendly report with colored output and
actionable installation instructions for missing dependencies.

IMPORTANT: CMake is the source of truth for all dependency requirements.
This script only formats output and provides help text.
"""

import json
import sys
from pathlib import Path
from typing import Dict, List, Optional

# Import prereqs utilities
try:
    from prereqs import detect_platform
    from prereqs.requirements import (
        PythonRequirement,
        TorchRequirement,
        LLVMRequirement,
        CUDAToolkitRequirement,
        Pybind11Requirement,
        CompilerRequirement,
        GitSubmodulesRequirement,
        NinjaRequirement,
    )
    HELP_AVAILABLE = True
except ImportError:
    # Fallback if prereqs not available
    print("Warning: prereqs package not found. Platform-specific help unavailable.", file=sys.stderr)
    detect_platform = lambda: {"os": "unknown", "arch": "unknown", "ubuntu_based": False}
    PythonRequirement = None
    HELP_AVAILABLE = False


class Colors:
    """ANSI color codes for terminal output"""
    RESET = "\033[m"
    BOLD = "\033[1m"

    # Regular colors
    GREEN = "\033[32m"
    YELLOW = "\033[33m"
    CYAN = "\033[36m"
    WHITE = "\033[37m"

    # Bold colors
    BOLD_RED = "\033[1;31m"
    BOLD_GREEN = "\033[1;32m"
    BOLD_WHITE = "\033[1;37m"


class DependencyReporter:
    """
    Generates formatted dependency reports from JSON data with help text.

    CMake provides all dependency data via JSON. This class formats the output
    and generates platform-specific installation instructions for failures.
    """

    def __init__(self, deps_path: Path):
        # Load CMake variables
        cmake_vars = self._load_cmake_vars(deps_path)

        self.colors = Colors()
        self.platform_info = detect_platform()

        # Create requirement objects - each class defines its own name and variable names
        self.requirements = []
        if HELP_AVAILABLE:
            self.requirements.append(GitSubmodulesRequirement(cmake_vars))
            self.requirements.append(NinjaRequirement(cmake_vars))
            self.requirements.append(CompilerRequirement(cmake_vars))
            self.requirements.append(PythonRequirement(cmake_vars))
            self.requirements.append(CUDAToolkitRequirement(cmake_vars))
            self.requirements.append(TorchRequirement(cmake_vars))
            self.requirements.append(Pybind11Requirement(cmake_vars))
            self.requirements.append(LLVMRequirement(cmake_vars))

    def _load_cmake_vars(self, deps_path: Path) -> Dict:
        """Load CMake variables from JSON file"""
        try:
            with open(deps_path, 'r') as f:
                data = json.load(f)
                return data.get("cmake_vars", {})
        except FileNotFoundError:
            print(f"Error: {deps_path} not found", file=sys.stderr)
            sys.exit(1)
        except Exception as e:
            print(f"Error loading dependencies: {e}", file=sys.stderr)
            sys.exit(1)


    def generate_report(self):
        """Main entry point - prints formatted report"""
        self._print_header()
        self._print_dependencies()

        # Collect failures and print help if needed
        failures = [req for req in self.requirements if hasattr(req, 'is_failure') and req.is_failure()]
        if failures:
            self._print_help_section(failures)
            self._print_failure_summary()

        print()  # Blank line at end

    def _print_header(self):
        """Print report header"""
        print()
        print(f"{self.colors.BOLD_GREEN}[nvFuser] Validating build prerequisites...{self.colors.RESET}")
        print()

    def _print_failure_summary(self):
        """Print failure summary message"""
        print()
        print(f"{self.colors.BOLD_RED}Build prerequisite validation FAILED{self.colors.RESET}")
        print(f"{self.colors.WHITE}See installation instructions above{self.colors.RESET}")

    def _print_dependencies(self):
        """Print status for each dependency using OOP requirement classes"""
        for req in self.requirements:
            if hasattr(req, 'format_status_line'):
                # OOP: use requirement's format method
                print(req.format_status_line(self.colors))
            else:
                # Fallback: use legacy dict-based formatting (shouldn't happen)
                print(f"[nvFuser] ? {req.get('name', 'Unknown')}")

    def _print_help_section(self, failures):
        """Print help section header and help for each failed dependency"""
        print()
        print("=" * 70)
        print("Installation Instructions")
        print("=" * 70)
        print()

        for req in failures:
            self._print_help_for_requirement(req)

    def _print_help_for_requirement(self, req):
        """Call requirement's help generation method"""
        if hasattr(req, 'generate_help'):
            req.generate_help(self.platform_info)
        else:
            # Fallback for requirements without help
            print(f"{req.name} installation help not available")
            print()


def main():
    if len(sys.argv) != 2:
        print("Usage: check_dependencies.py <deps.json>", file=sys.stderr)
        sys.exit(1)

    json_path = Path(sys.argv[1])
    if not json_path.exists():
        print(f"Error: {json_path} not found", file=sys.stderr)
        sys.exit(1)

    # Generate report
    reporter = DependencyReporter(json_path)
    reporter.generate_report()

    # Python doesn't determine success/failure - that's CMake's job
    # We just print a pretty report and always exit 0
    sys.exit(0)


if __name__ == "__main__":
    main()
