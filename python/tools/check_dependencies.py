#!/usr/bin/env python3
"""
nvFuser Dependency Report Generator

Reads dependency data from JSON (generated by CMake) and prints
a comprehensive, user-friendly report with colored output and
actionable installation instructions for missing dependencies.

IMPORTANT: CMake is the source of truth for all dependency requirements.
This script only formats output and provides help text.
"""

import json
import sys
from pathlib import Path
from typing import Dict, List, Optional

# Import prereqs utilities
try:
    from prereqs import detect_platform
    from prereqs.help import (
        PythonHelp,
        TorchHelp,
        CUDAToolkitHelp,
        TorchCUDAConstraintHelp,
        Pybind11Help,
        LLVMHelp,
        CompilerHelp,
        GitSubmodulesHelp,
        NinjaHelp,
        CMakeHelp,
        GenericHelp,
    )
    HELP_AVAILABLE = True
except ImportError:
    # Fallback if prereqs not available
    print("Warning: prereqs package not found. Platform-specific help unavailable.", file=sys.stderr)
    detect_platform = lambda: {"os": "unknown", "arch": "unknown", "ubuntu_based": False}
    HELP_AVAILABLE = False


class Colors:
    """ANSI color codes for terminal output"""
    RESET = "\033[m"
    BOLD = "\033[1m"

    # Regular colors
    GREEN = "\033[32m"
    YELLOW = "\033[33m"
    CYAN = "\033[36m"
    WHITE = "\033[37m"

    # Bold colors
    BOLD_RED = "\033[1;31m"
    BOLD_GREEN = "\033[1;32m"
    BOLD_WHITE = "\033[1;37m"


class DependencyReporter:
    """
    Generates formatted dependency reports from JSON data with help text.

    CMake provides all dependency data via JSON. This class formats the output
    and generates platform-specific installation instructions for failures.
    """

    def __init__(self, json_path: Path):
        self.data = self._load_json(json_path)
        self.colors = Colors()
        self.failures: List[Dict] = []  # Store failure dicts for help generation
        self.platform_info = detect_platform()

        # Initialize help providers if available
        if HELP_AVAILABLE:
            self.help_providers = {
                "Python": PythonHelp(self.platform_info),
                "Torch": TorchHelp(self.platform_info),
                "CUDAToolkit": CUDAToolkitHelp(self.platform_info),
                "Torch_CUDA": TorchCUDAConstraintHelp(self.platform_info),
                "pybind11": Pybind11Help(self.platform_info),
                "LLVM": LLVMHelp(self.platform_info),
                "GCC": CompilerHelp(self.platform_info),
                "Clang": CompilerHelp(self.platform_info),
                "Compiler": CompilerHelp(self.platform_info),
                "Git": GitSubmodulesHelp(self.platform_info),
                "GitSubmodules": GitSubmodulesHelp(self.platform_info),
                "Ninja": NinjaHelp(self.platform_info),
                "CMake": CMakeHelp(self.platform_info),
            }
            self.generic_help = GenericHelp(self.platform_info)
        else:
            self.help_providers = {}
            self.generic_help = None

    def _load_json(self, json_path: Path) -> Dict:
        """Load and parse the dependency JSON file"""
        try:
            with open(json_path, 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            print(f"Error: {json_path} not found", file=sys.stderr)
            sys.exit(1)
        except json.JSONDecodeError as e:
            print(f"Error: Invalid JSON in {json_path}: {e}", file=sys.stderr)
            sys.exit(1)

    def generate_report(self):
        """Main entry point - prints formatted report"""
        self._print_header()
        self._print_dependencies()

        # Print help text if there were failures
        if self.failures:
            self._print_help_section()
            self._print_failure_summary()

        print()  # Blank line at end

    def _print_header(self):
        """Print report header"""
        print()
        print(f"{self.colors.BOLD_GREEN}[nvFuser] Validating build prerequisites...{self.colors.RESET}")
        print()

    def _print_failure_summary(self):
        """Print failure summary message"""
        print()
        print(f"{self.colors.BOLD_RED}Build prerequisite validation FAILED{self.colors.RESET}")
        print(f"{self.colors.WHITE}See installation instructions above{self.colors.RESET}")

    def _print_dependencies(self):
        """Print status for each dependency"""
        for dep in self.data["dependencies"]:
            status = dep["status"]

            if status == "SUCCESS":
                self._print_success(dep)
            elif status == "NOT_FOUND":
                self._print_not_found(dep)
            elif status == "INCOMPATIBLE":
                self._print_incompatible(dep)

            # Check if this dependency has constraint checks to display
            if "extra" in dep:
                self._print_constraints(dep)

    def _print_success(self, dep: Dict):
        """Print success line for found dependency"""
        name = dep["name"]
        version = dep.get("version_found")
        version_min = dep.get("version_required")

        # Format: [nvFuser] ✓ Python 3.12.3 >= 3.8
        if version and version_min:
            print(f"{self.colors.GREEN}[nvFuser] ✓ {name} {version} >= {version_min}{self.colors.RESET}")
        elif version:
            print(f"{self.colors.GREEN}[nvFuser] ✓ {name} {version}{self.colors.RESET}")
        else:
            print(f"{self.colors.GREEN}[nvFuser] ✓ {name}{self.colors.RESET}")

    def _print_not_found(self, dep: Dict):
        """Print line for missing dependency"""
        name = dep["name"]
        version_min = dep.get("version_required")
        optional = dep.get("optional", False)

        if optional:
            # Yellow ○ for optional
            if version_min:
                print(f"{self.colors.YELLOW}[nvFuser] ○ {name} NOT found (optional, v{version_min}+ recommended){self.colors.RESET}")
            else:
                print(f"{self.colors.YELLOW}[nvFuser] ○ {name} NOT found (optional){self.colors.RESET}")
        else:
            # Red ✗ for required
            if version_min:
                print(f"{self.colors.BOLD_RED}[nvFuser] ✗ {name} NOT found (requires {version_min}+){self.colors.RESET}")
            else:
                print(f"{self.colors.BOLD_RED}[nvFuser] ✗ {name} NOT found{self.colors.RESET}")

            # Store failure for help generation
            self.failures.append(dep)

    def _print_incompatible(self, dep: Dict):
        """Print line for incompatible dependency (wrong version)"""
        name = dep["name"]
        version = dep.get("version_found")
        version_min = dep.get("version_required")

        # Format: [nvFuser] ✗ Python 3.7.0 < 3.8
        if version and version_min:
            print(f"{self.colors.BOLD_RED}[nvFuser] ✗ {name} {version} < {version_min}{self.colors.RESET}")
        else:
            print(f"{self.colors.BOLD_RED}[nvFuser] ✗ {name} incompatible{self.colors.RESET}")

        # Store failure for help generation
        self.failures.append(dep)

    def _print_constraints(self, dep: Dict):
        """Print constraint validation results (e.g., Torch_CUDA)"""
        extra = dep.get("extra", {})
        parent_name = dep["name"]

        # Handle CUDA constraint for Torch
        if "constraint_cuda_status" in extra:
            cuda_status = extra["constraint_cuda_status"]
            constraint_name = f"{parent_name}_CUDA"

            if cuda_status == "match":
                # Constraint satisfied
                version = extra.get("constraint_cuda_version", "")
                print(f"{self.colors.GREEN}[nvFuser] ✓ {constraint_name} {version} (Torch.CUDA == CUDAToolkit){self.colors.RESET}")

            elif cuda_status == "mismatch":
                # Constraint violated
                found_version = extra.get("constraint_cuda_found", "")
                required_version = extra.get("constraint_cuda_required", "")
                print(f"{self.colors.BOLD_RED}[nvFuser] ✗ {constraint_name} mismatch: Torch {found_version} != CUDAToolkit {required_version}{self.colors.RESET}")

                # Add constraint failure to help list
                constraint_dep = dep.copy()
                constraint_dep["name"] = constraint_name
                constraint_dep["constraint_type"] = "cuda_mismatch"
                constraint_dep["constraint_found"] = found_version
                constraint_dep["constraint_required"] = required_version
                self.failures.append(constraint_dep)

            elif cuda_status == "not_available":
                # CUDA not available in Torch
                print(f"{self.colors.BOLD_RED}[nvFuser] ✗ {constraint_name} N/A (Torch not built with CUDA){self.colors.RESET}")

                constraint_dep = dep.copy()
                constraint_dep["name"] = constraint_name
                constraint_dep["constraint_type"] = "cuda_unavailable"
                self.failures.append(constraint_dep)

    def _print_help_section(self):
        """Print installation instructions for all failures"""
        print()
        print("=" * 70)
        print("Installation Instructions")
        print("=" * 70)
        print()

        for failure in self.failures:
            self._print_help_for_dependency(failure)

    def _print_help_for_dependency(self, failure: Dict):
        """Dispatch to specific help provider based on dependency name"""
        if not HELP_AVAILABLE:
            # Fallback if help system not available
            name = failure["name"]
            print(f"{name} installation help not available (prereqs package missing)")
            print()
            return

        name = failure["name"]
        help_provider = self.help_providers.get(name, self.generic_help)
        help_provider.generate_help(failure)


def main():
    if len(sys.argv) != 2:
        print("Usage: check_dependencies.py <deps.json>", file=sys.stderr)
        sys.exit(1)

    json_path = Path(sys.argv[1])
    if not json_path.exists():
        print(f"Error: {json_path} not found", file=sys.stderr)
        sys.exit(1)

    # Generate report
    reporter = DependencyReporter(json_path)
    reporter.generate_report()

    # Python doesn't determine success/failure - that's CMake's job
    # We just print a pretty report and always exit 0
    sys.exit(0)


if __name__ == "__main__":
    main()
