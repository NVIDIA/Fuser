#!/usr/bin/env python3
"""
nvFuser Dependency Report Generator

Reads dependency data from JSON (generated by CMake) and prints
a comprehensive, user-friendly report with colored output and
actionable installation instructions for missing dependencies.

IMPORTANT: CMake is the source of truth for all dependency requirements.
This script only formats output and provides help text.
"""

import json
import sys
from pathlib import Path
from typing import Dict, List, Optional

# Import prereqs utilities
try:
    from prereqs import detect_platform
    from prereqs.requirements import (
        PythonRequirement,
        TorchRequirement,
        LLVMRequirement,
        CUDAToolkitRequirement,
        Pybind11Requirement,
        CompilerRequirement,
        GitSubmodulesRequirement,
        NinjaRequirement,
    )
    from prereqs.help import (
        PythonHelp,
        TorchHelp,
        CUDAToolkitHelp,
        TorchCUDAConstraintHelp,
        Pybind11Help,
        LLVMHelp,
        CompilerHelp,
        GitSubmodulesHelp,
        NinjaHelp,
        CMakeHelp,
        GenericHelp,
    )
    HELP_AVAILABLE = True
except ImportError:
    # Fallback if prereqs not available
    print("Warning: prereqs package not found. Platform-specific help unavailable.", file=sys.stderr)
    detect_platform = lambda: {"os": "unknown", "arch": "unknown", "ubuntu_based": False}
    PythonRequirement = None
    HELP_AVAILABLE = False


class Colors:
    """ANSI color codes for terminal output"""
    RESET = "\033[m"
    BOLD = "\033[1m"

    # Regular colors
    GREEN = "\033[32m"
    YELLOW = "\033[33m"
    CYAN = "\033[36m"
    WHITE = "\033[37m"

    # Bold colors
    BOLD_RED = "\033[1;31m"
    BOLD_GREEN = "\033[1;32m"
    BOLD_WHITE = "\033[1;37m"


class DependencyReporter:
    """
    Generates formatted dependency reports from JSON data with help text.

    CMake provides all dependency data via JSON. This class formats the output
    and generates platform-specific installation instructions for failures.
    """

    def __init__(self, deps_path: Path):
        # Load CMake variables
        cmake_vars = self._load_cmake_vars(deps_path)

        self.colors = Colors()
        self.platform_info = detect_platform()

        # Create requirement objects - explicitly instantiate each dependency
        # Dependency order matches CMake validation order
        self.requirements = []
        if HELP_AVAILABLE:
            # GitSubmodules
            self.requirements.append(GitSubmodulesRequirement(
                name="GitSubmodules",
                found=cmake_vars.get("GitSubmodules_FOUND", "FALSE"),
                status=cmake_vars.get("GitSubmodules_STATUS", "UNKNOWN"),
                optional=cmake_vars.get("NVFUSER_REQUIREMENT_GitSubmodules_OPTIONAL", "FALSE"),
                location=cmake_vars.get(cmake_vars.get("NVFUSER_REQUIREMENT_GitSubmodules_LOCATION_VAR", ""), ""),
            ))

            # Ninja
            self.requirements.append(NinjaRequirement(
                name="Ninja",
                found=cmake_vars.get("Ninja_FOUND", "FALSE"),
                status=cmake_vars.get("Ninja_STATUS", "UNKNOWN"),
                optional=cmake_vars.get("NVFUSER_REQUIREMENT_Ninja_OPTIONAL", "FALSE"),
                location=cmake_vars.get(cmake_vars.get("NVFUSER_REQUIREMENT_Ninja_LOCATION_VAR", ""), ""),
            ))

            # Compiler (GCC or Clang)
            compiler_name = cmake_vars.get("Compiler_NAME", "Compiler")
            self.requirements.append(CompilerRequirement(
                name=compiler_name,
                found=cmake_vars.get("Compiler_FOUND", "FALSE"),
                status=cmake_vars.get("Compiler_STATUS", "UNKNOWN"),
                optional=cmake_vars.get("NVFUSER_REQUIREMENT_Compiler_OPTIONAL", "FALSE"),
                version_found=cmake_vars.get("Compiler_VERSION"),
                version_required=cmake_vars.get("NVFUSER_REQUIREMENT_Compiler_VERSION_MIN"),
                location=cmake_vars.get(cmake_vars.get("NVFUSER_REQUIREMENT_Compiler_LOCATION_VAR", ""), ""),
            ))

            # Python
            self.requirements.append(PythonRequirement(
                name="Python",
                found=cmake_vars.get("Python_FOUND", "FALSE"),
                status=cmake_vars.get("Python_STATUS", "UNKNOWN"),
                optional=cmake_vars.get("NVFUSER_REQUIREMENT_Python_OPTIONAL", "FALSE"),
                version_found=cmake_vars.get("Python_VERSION"),
                version_required=cmake_vars.get("NVFUSER_REQUIREMENT_Python_VERSION_MIN"),
                location=cmake_vars.get(cmake_vars.get("NVFUSER_REQUIREMENT_Python_LOCATION_VAR", ""), ""),
            ))

            # CUDAToolkit
            self.requirements.append(CUDAToolkitRequirement(
                name="CUDAToolkit",
                found=cmake_vars.get("CUDAToolkit_FOUND", "FALSE"),
                status=cmake_vars.get("CUDAToolkit_STATUS", "UNKNOWN"),
                optional=cmake_vars.get("NVFUSER_REQUIREMENT_CUDAToolkit_OPTIONAL", "FALSE"),
                version_found=cmake_vars.get("CUDAToolkit_VERSION"),
                version_required=cmake_vars.get("NVFUSER_REQUIREMENT_CUDAToolkit_VERSION_MIN"),
                location=cmake_vars.get(cmake_vars.get("NVFUSER_REQUIREMENT_CUDAToolkit_LOCATION_VAR", ""), ""),
            ))

            # Torch
            self.requirements.append(TorchRequirement(
                name="Torch",
                found=cmake_vars.get("Torch_FOUND", "FALSE"),
                status=cmake_vars.get("Torch_STATUS", "UNKNOWN"),
                optional=cmake_vars.get("NVFUSER_REQUIREMENT_Torch_OPTIONAL", "FALSE"),
                version_found=cmake_vars.get("Torch_VERSION"),
                version_required=cmake_vars.get("NVFUSER_REQUIREMENT_Torch_VERSION_MIN"),
                location=cmake_vars.get(cmake_vars.get("NVFUSER_REQUIREMENT_Torch_LOCATION_VAR", ""), ""),
                torch_cuda_constraint_status=cmake_vars.get("Torch_CUDA_constraint_status"),
                torch_cuda_constraint_version=cmake_vars.get("Torch_CUDA_constraint_version"),
                torch_cuda_constraint_found=cmake_vars.get("Torch_CUDA_constraint_found"),
                torch_cuda_constraint_required=cmake_vars.get("Torch_CUDA_constraint_required"),
            ))

            # pybind11
            self.requirements.append(Pybind11Requirement(
                name="pybind11",
                found=cmake_vars.get("pybind11_FOUND", "FALSE"),
                status=cmake_vars.get("pybind11_STATUS", "UNKNOWN"),
                optional=cmake_vars.get("NVFUSER_REQUIREMENT_pybind11_OPTIONAL", "FALSE"),
                version_found=cmake_vars.get("pybind11_VERSION"),
                version_required=cmake_vars.get("NVFUSER_REQUIREMENT_pybind11_VERSION_MIN"),
                location=cmake_vars.get(cmake_vars.get("NVFUSER_REQUIREMENT_pybind11_LOCATION_VAR", ""), ""),
            ))

            # LLVM
            self.requirements.append(LLVMRequirement(
                name="LLVM",
                found=cmake_vars.get("LLVM_FOUND", "FALSE"),
                status=cmake_vars.get("LLVM_STATUS", "UNKNOWN"),
                optional=cmake_vars.get("NVFUSER_REQUIREMENT_LLVM_OPTIONAL", "FALSE"),
                version_found=cmake_vars.get("LLVM_VERSION"),
                version_required=cmake_vars.get("NVFUSER_REQUIREMENT_LLVM_VERSION_MIN"),
                location=cmake_vars.get(cmake_vars.get("NVFUSER_REQUIREMENT_LLVM_LOCATION_VAR", ""), ""),
            ))

        # Initialize help providers if available
        if HELP_AVAILABLE:
            self.help_providers = {
                "Python": PythonHelp(self.platform_info),
                "Torch": TorchHelp(self.platform_info),
                "CUDAToolkit": CUDAToolkitHelp(self.platform_info),
                "Torch_CUDA": TorchCUDAConstraintHelp(self.platform_info),
                "pybind11": Pybind11Help(self.platform_info),
                "LLVM": LLVMHelp(self.platform_info),
                "GCC": CompilerHelp(self.platform_info),
                "Clang": CompilerHelp(self.platform_info),
                "Compiler": CompilerHelp(self.platform_info),
                "Git": GitSubmodulesHelp(self.platform_info),
                "GitSubmodules": GitSubmodulesHelp(self.platform_info),
                "Ninja": NinjaHelp(self.platform_info),
                "CMake": CMakeHelp(self.platform_info),
            }
            self.generic_help = GenericHelp(self.platform_info)
        else:
            self.help_providers = {}
            self.generic_help = None

    def _load_cmake_vars(self, deps_path: Path) -> Dict:
        """Load CMake variables from JSON file"""
        try:
            with open(deps_path, 'r') as f:
                data = json.load(f)
                return data.get("cmake_vars", {})
        except FileNotFoundError:
            print(f"Error: {deps_path} not found", file=sys.stderr)
            sys.exit(1)
        except Exception as e:
            print(f"Error loading dependencies: {e}", file=sys.stderr)
            sys.exit(1)


    def generate_report(self):
        """Main entry point - prints formatted report"""
        self._print_header()
        self._print_dependencies()

        # Collect failures and print help if needed
        failures = [req for req in self.requirements if hasattr(req, 'is_failure') and req.is_failure()]
        if failures:
            self._print_help_section(failures)
            self._print_failure_summary()

        print()  # Blank line at end

    def _print_header(self):
        """Print report header"""
        print()
        print(f"{self.colors.BOLD_GREEN}[nvFuser] Validating build prerequisites...{self.colors.RESET}")
        print()

    def _print_failure_summary(self):
        """Print failure summary message"""
        print()
        print(f"{self.colors.BOLD_RED}Build prerequisite validation FAILED{self.colors.RESET}")
        print(f"{self.colors.WHITE}See installation instructions above{self.colors.RESET}")

    def _print_dependencies(self):
        """Print status for each dependency using OOP requirement classes"""
        for req in self.requirements:
            if hasattr(req, 'format_status_line'):
                # OOP: use requirement's format method
                print(req.format_status_line(self.colors))
            else:
                # Fallback: use legacy dict-based formatting (shouldn't happen)
                print(f"[nvFuser] ? {req.get('name', 'Unknown')}")

    def _print_help_section(self, failures):
        """Print help section header and help for each failed dependency"""
        print()
        print("=" * 70)
        print("Installation Instructions")
        print("=" * 70)
        print()

        for req in failures:
            self._print_help_for_requirement(req)

    def _print_help_for_requirement(self, req):
        """Dispatch to specific help provider based on requirement"""
        if not HELP_AVAILABLE:
            # Fallback if help system not available
            name = req.name if hasattr(req, 'name') else req.get('name', 'Unknown')
            print(f"{name} installation help not available (prereqs package missing)")
            print()
            return

        # Get failure data for help provider
        failure_data = req.get_failure_data() if hasattr(req, 'get_failure_data') else req

        name = failure_data.get("name", "Unknown")
        help_provider = self.help_providers.get(name, self.generic_help)
        help_provider.generate_help(failure_data)


def main():
    if len(sys.argv) != 2:
        print("Usage: check_dependencies.py <deps.json>", file=sys.stderr)
        sys.exit(1)

    json_path = Path(sys.argv[1])
    if not json_path.exists():
        print(f"Error: {json_path} not found", file=sys.stderr)
        sys.exit(1)

    # Generate report
    reporter = DependencyReporter(json_path)
    reporter.generate_report()

    # Python doesn't determine success/failure - that's CMake's job
    # We just print a pretty report and always exit 0
    sys.exit(0)


if __name__ == "__main__":
    main()
