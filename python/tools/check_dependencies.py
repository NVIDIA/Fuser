#!/usr/bin/env python3
"""
nvFuser Dependency Report Generator

Reads dependency data from JSON (generated by CMake) and prints
a comprehensive, user-friendly report with colored output and
actionable installation instructions for missing dependencies.

IMPORTANT: CMake is the source of truth for all dependency requirements.
This script only formats output and provides help text.
"""

import json
import sys
from pathlib import Path
from typing import Dict, List, Optional

# Import prereqs utilities
try:
    from prereqs import (
        detect_platform,
        pytorch_index_url,
        pytorch_install_instructions,
        llvm_download_url,
        cuda_toolkit_download_url,
        parse_version,
    )
except ImportError:
    # Fallback if prereqs not available
    print("Warning: prereqs package not found. Platform-specific help unavailable.", file=sys.stderr)
    detect_platform = lambda: {"os": "unknown", "arch": "unknown", "ubuntu_based": False}
    pytorch_index_url = lambda cuda: f"https://download.pytorch.org/whl/cu{cuda[0]}{cuda[1]}"
    pytorch_install_instructions = lambda _: "pip install torch"
    llvm_download_url = lambda v=None: "https://github.com/llvm/llvm-project/releases"
    cuda_toolkit_download_url = lambda: "https://developer.nvidia.com/cuda-downloads"
    parse_version = lambda v: tuple(map(int, v.split(".")))


class Colors:
    """ANSI color codes for terminal output"""
    RESET = "\033[m"
    BOLD = "\033[1m"

    # Regular colors
    GREEN = "\033[32m"
    YELLOW = "\033[33m"
    CYAN = "\033[36m"
    WHITE = "\033[37m"

    # Bold colors
    BOLD_RED = "\033[1;31m"
    BOLD_GREEN = "\033[1;32m"
    BOLD_WHITE = "\033[1;37m"


class DependencyReporter:
    """
    Generates formatted dependency reports from JSON data with help text.

    CMake provides all dependency data via JSON. This class formats the output
    and generates platform-specific installation instructions for failures.
    """

    def __init__(self, json_path: Path):
        self.data = self._load_json(json_path)
        self.colors = Colors()
        self.failures: List[Dict] = []  # Store failure dicts for help generation
        self.platform_info = detect_platform()

    def _load_json(self, json_path: Path) -> Dict:
        """Load and parse the dependency JSON file"""
        try:
            with open(json_path, 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            print(f"Error: {json_path} not found", file=sys.stderr)
            sys.exit(1)
        except json.JSONDecodeError as e:
            print(f"Error: Invalid JSON in {json_path}: {e}", file=sys.stderr)
            sys.exit(1)

    def generate_report(self):
        """Main entry point - prints formatted report"""
        self._print_header()
        self._print_dependencies()

        # Print help text if there were failures
        if self.failures:
            self._print_help_section()
            self._print_failure_summary()

        print()  # Blank line at end

    def _print_header(self):
        """Print report header"""
        print()
        print(f"{self.colors.BOLD_GREEN}[nvFuser] Validating build prerequisites...{self.colors.RESET}")
        print()

    def _print_failure_summary(self):
        """Print failure summary message"""
        print()
        print(f"{self.colors.BOLD_RED}Build prerequisite validation FAILED{self.colors.RESET}")
        print(f"{self.colors.WHITE}See installation instructions above{self.colors.RESET}")

    def _print_dependencies(self):
        """Print status for each dependency"""
        for dep in self.data["dependencies"]:
            status = dep["status"]

            if status == "SUCCESS":
                self._print_success(dep)
            elif status == "NOT_FOUND":
                self._print_not_found(dep)
            elif status == "INCOMPATIBLE":
                self._print_incompatible(dep)

            # Check if this dependency has constraint checks to display
            if "extra" in dep:
                self._print_constraints(dep)

    def _print_success(self, dep: Dict):
        """Print success line for found dependency"""
        name = dep["name"]
        version = dep.get("version_found")
        version_min = dep.get("version_required")

        # Format: [nvFuser] ✓ Python 3.12.3 >= 3.8
        if version and version_min:
            print(f"{self.colors.GREEN}[nvFuser] ✓ {name} {version} >= {version_min}{self.colors.RESET}")
        elif version:
            print(f"{self.colors.GREEN}[nvFuser] ✓ {name} {version}{self.colors.RESET}")
        else:
            print(f"{self.colors.GREEN}[nvFuser] ✓ {name}{self.colors.RESET}")

    def _print_not_found(self, dep: Dict):
        """Print line for missing dependency"""
        name = dep["name"]
        version_min = dep.get("version_required")
        optional = dep.get("optional", False)

        if optional:
            # Yellow ○ for optional
            if version_min:
                print(f"{self.colors.YELLOW}[nvFuser] ○ {name} NOT found (optional, v{version_min}+ recommended){self.colors.RESET}")
            else:
                print(f"{self.colors.YELLOW}[nvFuser] ○ {name} NOT found (optional){self.colors.RESET}")
        else:
            # Red ✗ for required
            if version_min:
                print(f"{self.colors.BOLD_RED}[nvFuser] ✗ {name} NOT found (requires {version_min}+){self.colors.RESET}")
            else:
                print(f"{self.colors.BOLD_RED}[nvFuser] ✗ {name} NOT found{self.colors.RESET}")

            # Store failure for help generation
            self.failures.append(dep)

    def _print_incompatible(self, dep: Dict):
        """Print line for incompatible dependency (wrong version)"""
        name = dep["name"]
        version = dep.get("version_found")
        version_min = dep.get("version_required")

        # Format: [nvFuser] ✗ Python 3.7.0 < 3.8
        if version and version_min:
            print(f"{self.colors.BOLD_RED}[nvFuser] ✗ {name} {version} < {version_min}{self.colors.RESET}")
        else:
            print(f"{self.colors.BOLD_RED}[nvFuser] ✗ {name} incompatible{self.colors.RESET}")

        # Store failure for help generation
        self.failures.append(dep)

    def _print_constraints(self, dep: Dict):
        """Print constraint validation results (e.g., Torch_CUDA)"""
        extra = dep.get("extra", {})
        parent_name = dep["name"]

        # Handle CUDA constraint for Torch
        if "constraint_cuda_status" in extra:
            cuda_status = extra["constraint_cuda_status"]
            constraint_name = f"{parent_name}_CUDA"

            if cuda_status == "match":
                # Constraint satisfied
                version = extra.get("constraint_cuda_version", "")
                print(f"{self.colors.GREEN}[nvFuser] ✓ {constraint_name} {version} (Torch.CUDA == CUDAToolkit){self.colors.RESET}")

            elif cuda_status == "mismatch":
                # Constraint violated
                found_version = extra.get("constraint_cuda_found", "")
                required_version = extra.get("constraint_cuda_required", "")
                print(f"{self.colors.BOLD_RED}[nvFuser] ✗ {constraint_name} mismatch: Torch {found_version} != CUDAToolkit {required_version}{self.colors.RESET}")

                # Add constraint failure to help list
                constraint_dep = dep.copy()
                constraint_dep["name"] = constraint_name
                constraint_dep["constraint_type"] = "cuda_mismatch"
                constraint_dep["constraint_found"] = found_version
                constraint_dep["constraint_required"] = required_version
                self.failures.append(constraint_dep)

            elif cuda_status == "not_available":
                # CUDA not available in Torch
                print(f"{self.colors.BOLD_RED}[nvFuser] ✗ {constraint_name} N/A (Torch not built with CUDA){self.colors.RESET}")

                constraint_dep = dep.copy()
                constraint_dep["name"] = constraint_name
                constraint_dep["constraint_type"] = "cuda_unavailable"
                self.failures.append(constraint_dep)

    def _print_help_section(self):
        """Print installation instructions for all failures"""
        print()
        print("=" * 70)
        print("Installation Instructions")
        print("=" * 70)
        print()

        for failure in self.failures:
            self._print_help_for_dependency(failure)

    def _print_help_for_dependency(self, failure: Dict):
        """Dispatch to specific help method based on dependency name"""
        name = failure["name"]

        # Dispatch to specific help methods
        if name == "Python":
            self._help_python(failure)
        elif name == "Torch":
            self._help_torch(failure)
        elif name == "CUDAToolkit":
            self._help_cudatoolkit(failure)
        elif name == "pybind11":
            self._help_pybind11(failure)
        elif name == "LLVM":
            self._help_llvm(failure)
        elif name == "Torch_CUDA":
            self._help_torch_cuda_constraint(failure)
        else:
            self._help_generic(failure)

    def _help_python(self, failure: Dict):
        """Generate Python installation help"""
        version_min = failure.get("version_required", "3.8")

        print(f"Python {version_min}+ Required")
        print()
        print("Why: nvFuser requires modern Python with type hints and language features.")
        print()
        print(f"Install Python {version_min} or higher:")
        print()

        os_type = self.platform_info["os"]

        if os_type == "Linux":
            if self.platform_info.get("ubuntu_based"):
                print("  Option 1: Ubuntu/Debian system package:")
                print()
                print("    sudo apt update")
                print(f"    sudo apt install python{version_min}")
                print()
            else:
                print("  Option 1: System package manager:")
                print()
                print(f"    # Example for RHEL/CentOS:")
                print(f"    # sudo yum install python{version_min}")
                print()

        elif os_type == "Darwin":
            print("  Option 1: Homebrew:")
            print()
            print(f"    brew install python@{version_min}")
            print()

        print("  Option 2: Conda:")
        print()
        print(f"    conda create -n nvfuser python={version_min}")
        print("    conda activate nvfuser")
        print()

    def _help_torch(self, failure: Dict):
        """Generate PyTorch installation help"""
        version_min = failure.get("version_required", "2.0")

        print(f"PyTorch {version_min}+ Required")
        print()
        print("Why: nvFuser is a PyTorch extension and requires PyTorch with CUDA support.")
        print()
        print(f"Install PyTorch {version_min} or higher with CUDA:")
        print()

        # Show install instructions for available CUDA versions
        print(pytorch_install_instructions())
        print()

    def _help_cudatoolkit(self, failure: Dict):
        """Generate CUDA Toolkit installation help"""
        version_min = failure.get("version_required", "12.6")

        print(f"CUDA Toolkit {version_min}+ Required")
        print()
        print("Why: nvFuser needs the CUDA compiler (nvcc) for GPU kernel generation.")
        print()
        print(f"Install CUDA Toolkit {version_min} or higher:")
        print()
        print("  Download from NVIDIA:")
        print()
        print(f"    {cuda_toolkit_download_url()}")
        print()
        print("  After installation, ensure CUDA is in your PATH:")
        print()
        print("    export PATH=/usr/local/cuda/bin:$PATH")
        print("    export LD_LIBRARY_PATH=/usr/local/cuda/lib64:$LD_LIBRARY_PATH")
        print()

    def _help_pybind11(self, failure: Dict):
        """Generate pybind11 installation help"""
        version_min = failure.get("version_required", "2.0")

        print(f"pybind11 {version_min}+ Required")
        print()
        print("Why: pybind11 provides Python bindings for nvFuser's C++ code.")
        print()
        print(f"Install pybind11 {version_min} or higher:")
        print()
        print("  pip install 'pybind11[global]>=2.0'")
        print()
        print("  Note: The [global] extra provides CMake integration.")
        print()

    def _help_llvm(self, failure: Dict):
        """Generate LLVM installation help"""
        version_min = failure.get("version_required", "18.1")
        recommended = "18.1.8"

        print(f"LLVM {version_min}+ Required")
        print()
        print("Why: nvFuser uses LLVM for runtime Host IR JIT compilation.")
        print()
        print(f"Install LLVM {recommended} (recommended):")
        print()

        print("  Option 1: Prebuilt binaries (recommended, no sudo needed):")
        print()

        try:
            url = llvm_download_url((18, 1, 8))
            print(f"    wget {url}")
            print(f"    tar -xf clang+llvm-{recommended}-*.tar.xz")
            print(f"    mv clang+llvm-{recommended}-* ~/.llvm/{recommended}")
            print()
            print("    # Add to PATH:")
            print(f"    export PATH=$HOME/.llvm/{recommended}/bin:$PATH")
            print()
        except NotImplementedError:
            print("    # Prebuilt binaries not available for your platform")
            print("    # See Option 2 below")
            print()

        print("  Option 2: System package manager:")
        print()

        os_type = self.platform_info["os"]

        if os_type == "Linux":
            if self.platform_info.get("ubuntu_based"):
                print("    # Ubuntu/Debian (LLVM APT repository):")
                print("    wget https://apt.llvm.org/llvm.sh")
                print("    chmod +x llvm.sh")
                print("    sudo ./llvm.sh 18")
                print()
            else:
                print("    # Check your distribution's package manager")
                print("    # Example for RHEL/CentOS:")
                print("    # sudo yum install llvm18")
                print()

        elif os_type == "Darwin":
            print("    brew install llvm@18")
            print()
            print("    # Add to PATH:")
            print("    export PATH=/opt/homebrew/opt/llvm@18/bin:$PATH")
            print()

    def _help_torch_cuda_constraint(self, failure: Dict):
        """Generate help for Torch CUDA version mismatch"""
        constraint_type = failure.get("constraint_type")

        if constraint_type == "cuda_mismatch":
            torch_cuda = failure.get("constraint_found", "")
            toolkit_cuda = failure.get("constraint_required", "")

            print(f"PyTorch/CUDA Version Mismatch")
            print()
            print(f"Why: PyTorch was built with CUDA {torch_cuda}, but system has CUDA Toolkit {toolkit_cuda}.")
            print("     These versions must match (major.minor) for nvFuser to work correctly.")
            print()
            print("Fix this by either:")
            print()
            print(f"  Option 1: Install PyTorch built for CUDA {toolkit_cuda}:")
            print()

            # Parse toolkit version to get install command
            try:
                toolkit_parts = parse_version(toolkit_cuda)
                if len(toolkit_parts) >= 2:
                    print(pytorch_install_instructions(cuda_major=toolkit_parts[0]))
                else:
                    print(pytorch_install_instructions())
            except:
                print(pytorch_install_instructions())
            print()

            print(f"  Option 2: Install CUDA Toolkit {torch_cuda} to match PyTorch:")
            print()
            print(f"    {cuda_toolkit_download_url()}")
            print()

        elif constraint_type == "cuda_unavailable":
            print("PyTorch CUDA Support Missing")
            print()
            print("Why: nvFuser requires PyTorch with CUDA support, but your PyTorch")
            print("     installation was built without CUDA.")
            print()
            print("Install PyTorch with CUDA support:")
            print()
            print(pytorch_install_instructions())
            print()

    def _help_generic(self, failure: Dict):
        """Fallback help for unknown dependencies"""
        name = failure["name"]
        version_min = failure.get("version_required", "")

        if version_min:
            print(f"{name} {version_min}+ Required")
        else:
            print(f"{name} Required")
        print()
        print(f"Please install {name} and try again.")
        print()


def main():
    if len(sys.argv) != 2:
        print("Usage: check_dependencies.py <deps.json>", file=sys.stderr)
        sys.exit(1)

    json_path = Path(sys.argv[1])
    if not json_path.exists():
        print(f"Error: {json_path} not found", file=sys.stderr)
        sys.exit(1)

    # Generate report
    reporter = DependencyReporter(json_path)
    reporter.generate_report()

    # Python doesn't determine success/failure - that's CMake's job
    # We just print a pretty report and always exit 0
    sys.exit(0)


if __name__ == "__main__":
    main()
