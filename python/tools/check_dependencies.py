#!/usr/bin/env python3
"""
nvFuser Dependency Report Generator

Reads dependency data from JSON (generated by CMake) and prints
a comprehensive, user-friendly report with colored output.

This script provides enhanced reporting for nvFuser's dependencies,
matching the format of the CMake-based reporter but with better
extensibility for future enhancements.
"""

import json
import sys
from pathlib import Path
from typing import Dict, List, Optional


class Colors:
    """ANSI color codes for terminal output"""
    RESET = "\033[m"
    BOLD = "\033[1m"

    # Regular colors
    RED = "\033[31m"
    GREEN = "\033[32m"
    YELLOW = "\033[33m"
    BLUE = "\033[34m"
    CYAN = "\033[36m"
    WHITE = "\033[37m"

    # Bold colors
    BOLD_RED = "\033[1;31m"
    BOLD_GREEN = "\033[1;32m"
    BOLD_YELLOW = "\033[1;33m"
    BOLD_BLUE = "\033[1;34m"
    BOLD_WHITE = "\033[1;37m"


class DependencyReporter:
    """
    Generates formatted dependency reports from JSON data.

    Matches the output format of CMake's report_dependencies() for
    consistency, while providing a foundation for future enhancements.
    """

    def __init__(self, json_path: Path):
        self.data = self._load_json(json_path)
        self.colors = Colors()
        self.failures: List[str] = []

    def _load_json(self, json_path: Path) -> Dict:
        """Load and parse the dependency JSON file"""
        try:
            with open(json_path, 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            print(f"Error: {json_path} not found", file=sys.stderr)
            sys.exit(1)
        except json.JSONDecodeError as e:
            print(f"Error: Invalid JSON in {json_path}: {e}", file=sys.stderr)
            sys.exit(1)

    def generate_report(self):
        """Main entry point - prints formatted report"""
        self._print_header()
        self._print_dependencies()
        self._print_footer()

    def _print_header(self):
        """Print report header"""
        print()
        print(f"-- {self.colors.BOLD_BLUE}///////////////////////////////////////////{self.colors.RESET}")
        print(f"-- {self.colors.BOLD_WHITE}==========================================={self.colors.RESET}")
        print(f"-- {self.colors.BOLD_GREEN}[nvFuser] Validating build prerequisites...{self.colors.RESET}")
        print(f"-- {self.colors.BOLD_WHITE}==========================================={self.colors.RESET}")

    def _print_footer(self):
        """Print report footer"""
        print(f"-- {self.colors.BOLD_WHITE}==========================================={self.colors.RESET}")
        print(f"-- {self.colors.BOLD_BLUE}///////////////////////////////////////////{self.colors.RESET}")

    def _print_dependencies(self):
        """Print status for each dependency"""
        for dep in self.data["dependencies"]:
            status = dep["status"]

            if status == "SUCCESS":
                self._print_success(dep)
            elif status == "NOT_FOUND":
                self._print_not_found(dep)
            elif status == "INCOMPATIBLE":
                self._print_incompatible(dep)

            # Check if this dependency has constraint checks to display
            if "extra" in dep:
                self._print_constraints(dep)

    def _print_success(self, dep: Dict):
        """Print success line for found dependency"""
        name = dep["name"]
        version = dep.get("version_found")
        version_min = dep.get("version_required")
        location = dep.get("location", "")

        # Format badge
        badge = f"{self.colors.GREEN}[ OK ]{self.colors.RESET}"

        # Format name with padding (12 chars total)
        name_padded = self._pad_name(name)
        name_display = f"{self.colors.WHITE}{name_padded}{self.colors.RESET}"

        # Format version with comparison
        if version and version_min:
            version_display = self._format_version_comparison(version, version_min, False)
        elif version:
            version_padded = self._pad_version(version)
            version_display = f"{self.colors.GREEN}v{version}{version_padded}{self.colors.RESET}"
        else:
            # No version (e.g., header-only dependencies)
            version_display = " " * 16  # Padding to align with versioned deps

        # Format location
        location_display = f"{self.colors.CYAN}{location}{self.colors.RESET}" if location else ""

        print(f"-- {badge} {name_display}  {version_display}  {location_display}")

    def _print_not_found(self, dep: Dict):
        """Print line for missing dependency"""
        name = dep["name"]
        version_min = dep.get("version_required")
        optional = dep.get("optional", False)

        if optional:
            # Yellow [ -- ] for optional
            badge = f"{self.colors.YELLOW}[ -- ]{self.colors.RESET}"
            if version_min:
                msg = f"NOT found (optional, v{version_min}+ recommended)"
            else:
                msg = f"NOT found (optional)"
        else:
            # Red [FAIL] for required
            badge = f"{self.colors.BOLD_RED}[FAIL]{self.colors.RESET}"
            if version_min:
                msg = f"NOT found (requires v{version_min} or higher)"
                self.failures.append(f"{name}: not found (requires v{version_min} or higher)")
            else:
                msg = f"NOT found"
                self.failures.append(f"{name}: not found")

        print(f"-- {badge} {self.colors.WHITE}{name}{self.colors.RESET} {msg}")

    def _print_incompatible(self, dep: Dict):
        """Print line for incompatible dependency (wrong version)"""
        name = dep["name"]
        version = dep.get("version_found")
        version_min = dep.get("version_required")
        location = dep.get("location", "")

        # Format badge
        badge = f"{self.colors.BOLD_RED}[FAIL]{self.colors.RESET}"

        # Format name with padding
        name_padded = self._pad_name(name)
        name_display = f"{self.colors.WHITE}{name_padded}{self.colors.RESET}"

        # Format version with comparison (shows < symbol for incompatible)
        if version and version_min:
            version_display = self._format_version_comparison(version, version_min, False, incompatible=True)
        else:
            version_display = ""

        # Format location
        location_display = f"{self.colors.CYAN}{location}{self.colors.RESET}" if location else ""

        print(f"-- {badge} {name_display}  {version_display}  {location_display}")

        # Track failure
        if version and version_min:
            self.failures.append(f"{name}: found v{version}, but requires v{version_min} or higher")
        else:
            self.failures.append(f"{name}: incompatible")

    def _print_constraints(self, dep: Dict):
        """Print constraint validation results (e.g., Torch_CUDA)"""
        extra = dep.get("extra", {})
        parent_name = dep["name"]

        # Handle CUDA constraint for Torch
        if "constraint_cuda_status" in extra:
            cuda_status = extra["constraint_cuda_status"]

            # Format constraint name
            constraint_name = f"{parent_name}_CUDA"
            name_padded = self._pad_name(constraint_name)
            name_display = f"{self.colors.WHITE}{name_padded}{self.colors.RESET}"

            if cuda_status == "match":
                # Constraint satisfied
                version = extra.get("constraint_cuda_version", "")
                version_padded = self._pad_version(version)
                badge = f"{self.colors.GREEN}[ OK ]{self.colors.RESET}"
                version_display = f"{self.colors.GREEN}v{version}{version_padded}{self.colors.RESET}  (= {version})"
                location_display = f"{self.colors.CYAN}Torch.CUDA == CUDAToolkit{self.colors.RESET}"
                print(f"-- {badge} {name_display}  {version_display}  {location_display}")

            elif cuda_status == "mismatch":
                # Constraint violated
                found_version = extra.get("constraint_cuda_found", "")
                required_version = extra.get("constraint_cuda_required", "")
                badge = f"{self.colors.BOLD_RED}[FAIL]{self.colors.RESET}"
                msg = f"v{found_version} != {required_version} (Torch.CUDA != CUDAToolkit)"
                print(f"-- {badge} {self.colors.WHITE}{constraint_name}{self.colors.RESET} {msg}")
                self.failures.append(f"{constraint_name}: Torch built with CUDA v{found_version}, but CUDAToolkit is v{required_version}")

            elif cuda_status == "not_available":
                # CUDA not available in Torch
                badge = f"{self.colors.BOLD_RED}[FAIL]{self.colors.RESET}"
                print(f"-- {badge} {self.colors.WHITE}{constraint_name}{self.colors.RESET} N/A (Torch not built with CUDA)")
                self.failures.append(f"{constraint_name}: Torch not built with CUDA support")

    def _pad_name(self, name: str) -> str:
        """Pad name to 12 characters for alignment"""
        return name + (" " * max(0, 12 - len(name)))

    def _pad_version(self, version: str) -> str:
        """Pad version to 10 characters for alignment"""
        return " " * max(0, 10 - len(version))

    def _format_version_comparison(self, version: str, version_min: str,
                                   is_constraint: bool = False,
                                   incompatible: bool = False) -> str:
        """
        Format version with comparison symbol.

        Args:
            version: Found version
            version_min: Required version
            is_constraint: If True, use = symbol (exact match)
            incompatible: If True, use < symbol and red color
        """
        version_padded = self._pad_version(version)

        if is_constraint:
            # Constraint: exact match required
            symbol = "="
            color = self.colors.GREEN
        elif incompatible:
            # Incompatible: version too old
            symbol = "<"
            color = self.colors.BOLD_RED
        else:
            # Success: version meets requirement
            symbol = "â‰¥"
            color = self.colors.GREEN

        return f"{color}v{version}{version_padded}{self.colors.RESET}  ({symbol} {version_min})"

    def has_failures(self) -> bool:
        """Check if there were any failures"""
        return len(self.failures) > 0

    def get_failures(self) -> List[str]:
        """Get list of failure messages"""
        return self.failures


def main():
    if len(sys.argv) != 2:
        print("Usage: check_dependencies.py <deps.json>", file=sys.stderr)
        sys.exit(1)

    json_path = Path(sys.argv[1])
    if not json_path.exists():
        print(f"Error: {json_path} not found", file=sys.stderr)
        sys.exit(1)

    # Generate report
    reporter = DependencyReporter(json_path)
    reporter.generate_report()

    # Python doesn't determine success/failure - that's CMake's job
    # We just print a pretty report and always exit 0
    sys.exit(0)


if __name__ == "__main__":
    main()
