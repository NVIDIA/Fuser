#!/usr/bin/env python3
# SPDX-FileCopyrightText: Copyright (c) 2025-present NVIDIA CORPORATION & AFFILIATES.
# All rights reserved.
# SPDX-License-Identifier: BSD-3-Clause
"""
nvFuser Dependency Report Generator

Reads dependency data from JSON (generated by CMake) and prints
a comprehensive, user-friendly report with colored output and
actionable installation instructions for missing dependencies.

IMPORTANT: CMake is the source of truth for all dependency requirements.
This script only formats output and provides help text.
"""

import json
import os
import sys
from pathlib import Path
from typing import Dict

# Import prereqs utilities
try:
    from prereqs import detect_platform, format_platform_info
    from prereqs.requirements import (
        PythonRequirement,
        TorchRequirement,
        LLVMRequirement,
        CUDAToolkitRequirement,
        Pybind11Requirement,
        CompilerRequirement,
        NinjaRequirement,
        NVMMHRequirement,
        GitSubmodulesRequirement,
    )

    HELP_AVAILABLE = True
except ImportError:
    # Fallback if prereqs not available
    print(
        "Warning: prereqs package not found. Platform-specific help unavailable.",
        file=sys.stderr,
    )

    def detect_platform():
        return {"os": "unknown", "arch": "unknown", "ubuntu_based": False}

    def format_platform_info(x=None):
        return "unknown platform"

    HELP_AVAILABLE = False


class Colors:
    """ANSI color codes for terminal output"""

    _codes = {
        "RESET": "\033[m",
        "BOLD": "\033[1m",
        # Regular colors
        "GREEN": "\033[32m",
        "YELLOW": "\033[33m",
        "CYAN": "\033[36m",
        "WHITE": "\033[37m",
        # Bold colors
        "BOLD_RED": "\033[1;31m",
        "BOLD_GREEN": "\033[1;32m",
        "BOLD_WHITE": "\033[1;37m",
    }

    def __init__(self):
        use_colors = os.environ.get("NVFUSER_BUILD_DISABLE_COLOR") is None

        for name, code in self._codes.items():
            setattr(self, name, code if use_colors else "")


class DependencyReporter:
    """
    Generates formatted dependency reports from JSON data with help text.

    CMake provides all dependency data via JSON. This class formats the output
    and generates platform-specific installation instructions for failures.
    """

    def __init__(self, deps_path: Path):
        # Load CMake variables
        cmake_vars = self._load_cmake_vars(deps_path)

        self.colors = Colors()
        self.platform_info = detect_platform()

        # Create requirement objects - each class defines its own name and variable names
        self.requirements = []
        if HELP_AVAILABLE:
            self.requirements.append(NinjaRequirement(cmake_vars))
            self.requirements.append(GitSubmodulesRequirement(cmake_vars))
            self.requirements.append(CompilerRequirement(cmake_vars))
            self.requirements.append(PythonRequirement(cmake_vars))
            self.requirements.append(CUDAToolkitRequirement(cmake_vars))
            self.requirements.append(TorchRequirement(cmake_vars))
            self.requirements.append(Pybind11Requirement(cmake_vars))
            self.requirements.append(LLVMRequirement(cmake_vars))
            self.requirements.append(NVMMHRequirement(cmake_vars))

    def _load_cmake_vars(self, deps_path: Path) -> Dict:
        """Load CMake variables from JSON file"""
        try:
            with open(deps_path, "r") as f:
                data = json.load(f)
                return data.get("cmake_vars", {})
        except FileNotFoundError:
            print(f"Error: {deps_path} not found", file=sys.stderr)
            sys.exit(1)
        except Exception as e:
            print(f"Error loading dependencies: {e}", file=sys.stderr)
            sys.exit(1)

    def generate_report(self):
        """Main entry point - prints formatted report"""
        print()  # Blank line before report
        print("=" * 80)
        self._print_header()
        print("=" * 80)
        print()  # Blank line after header
        self._print_dependencies()
        print()  # Blank line after dependencies
        print("* Optional requirement")
        print("=" * 80)

        # Collect failures and issues to show help for
        # Include required failures (is_failure=True) and optional issues (not SUCCESS)
        failures = []
        for req in self.requirements:
            if hasattr(req, "is_failure") and req.is_failure():
                # Required dependency that failed
                failures.append(req)
            elif (
                hasattr(req, "status")
                and hasattr(req, "optional")
                and req.optional
                and req.status != "SUCCESS"
            ):
                # Optional dependency with issues (NOT_FOUND or INCOMPATIBLE)
                failures.append(req)

        if failures:
            self._print_help_section(failures)
            # Only print failure summary if there are actual (non-optional) failures
            required_failures = [
                req
                for req in self.requirements
                if hasattr(req, "is_failure") and req.is_failure()
            ]
            if required_failures:
                self._print_failure_summary()

        print()  # Blank line at end

    def _print_header(self):
        """Print report header with platform information"""
        platform_str = format_platform_info(self.platform_info)
        print(
            f"{self.colors.BOLD_GREEN}[nvFuser] Validating build prerequisites...{self.colors.RESET}"
        )
        print(f"{self.colors.CYAN}Platform: {platform_str}{self.colors.RESET}")

    def _print_failure_summary(self):
        """Print failure summary message"""
        print()
        print(
            f"{self.colors.BOLD_RED}Build prerequisite validation FAILED{self.colors.RESET}"
        )
        print("See installation instructions above")

    def _print_dependencies(self):
        """Print status for each dependency using OOP requirement classes"""
        for req in self.requirements:
            if hasattr(req, "format_status_line"):
                # OOP: use requirement's format method
                print(req.format_status_line(self.colors))
            else:
                # Fallback: use legacy dict-based formatting (shouldn't happen)
                print(f"[nvFuser] ? {getattr(req, 'name', 'Unknown')}")

    def _print_help_section(self, failures):
        """Print help section header and help for each failed dependency"""
        print()
        print("=" * 70)
        print("Installation Instructions")
        print("=" * 70)
        print()

        for req in failures:
            self._print_help_for_requirement(req)

    def _print_help_for_requirement(self, req):
        """Call requirement's help generation method"""
        if hasattr(req, "generate_help"):
            req.generate_help(self.platform_info)
        else:
            # Fallback for requirements without help
            print(f"{req.name} installation help not available")
            print()


def main():
    if len(sys.argv) != 2:
        print("Usage: check_dependencies.py <deps.json>", file=sys.stderr)
        sys.exit(1)

    json_path = Path(sys.argv[1])
    if not json_path.exists():
        print(f"Error: {json_path} not found", file=sys.stderr)
        sys.exit(1)

    # Generate report
    reporter = DependencyReporter(json_path)
    reporter.generate_report()

    # Report generated successfully
    sys.exit(0)


if __name__ == "__main__":
    main()
