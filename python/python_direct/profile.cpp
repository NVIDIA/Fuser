// clang-format off
/*
 * SPDX-FileCopyrightText: Copyright (c) 2025-present NVIDIA CORPORATION & AFFILIATES.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 */
// clang-format on
#include <nanobind/stl/string.h>
#include <nanobind/stl/vector.h>

#include <bindings.h>
#include <fusion_profiler.h>

namespace nvfuser::python {

namespace {

void bindFusionProfile(nb::module_& nvfuser) {
  nb::class_<KernelProfile> kernel_prof(nvfuser, "KernelProfile");
  kernel_prof.def("__repr__", [](KernelProfile& self) {
    std::stringstream ss;
    ss << self;
    return ss.str();
  });
  kernel_prof.def_prop_ro(
      "name", [](KernelProfile& self) { return self.name; }, R"(
Returns the kernel name.
)");
  kernel_prof.def_prop_ro(
      "segment_id", [](KernelProfile& self) { return self.segment_id; }, R"(
Returns the segment id of the kernel.
)");
  kernel_prof.def_prop_ro(
      "device", [](KernelProfile& self) { return self.device; }, R"(
Returns the device id where the kernel was executed.
)");
  kernel_prof.def_prop_ro(
      "stream", [](KernelProfile& self) { return self.stream; }, R"(
Returns the CUDA stream id used for kernel execution.
)");
  kernel_prof.def_prop_ro(
      "correlation_id",
      [](KernelProfile& self) { return self.correlation_id; },
      R"(
Returns the CUPTI correlation id for the kernel.
)");
  kernel_prof.def_prop_ro(
      "compile_time_ms",
      [](KernelProfile& self) { return self.compile_time_ms; },
      R"(
Returns the compile time in milliseconds of the kernel.
)");
  kernel_prof.def_prop_ro(
      "time_ms", [](KernelProfile& self) { return self.time_ms; }, R"(
Returns the execution time in milliseconds of the kernel.
)");
  kernel_prof.def_prop_ro(
      "effective_bandwidth_gbs",
      [](KernelProfile& self) { return self.effective_bandwidth_gbs; },
      R"(
Returns the effective bandwidth in gigabytes per second of the kernel.
)");
  kernel_prof.def_prop_ro(
      "percentage_peak_bandwidth",
      [](KernelProfile& self) { return self.percentage_peak_bandwidth; },
      R"(
Returns the percentage of peak bandwidth achieved by the kernel.
)");
  kernel_prof.def_prop_ro(
      "grid_str", [](KernelProfile& self) { return self.grid_str; }, R"(
Returns the grid dimensions as a string.
)");
  kernel_prof.def_prop_ro(
      "block_str", [](KernelProfile& self) { return self.block_str; }, R"(
Returns the block dimensions as a string.
)");
  kernel_prof.def_prop_ro(
      "cluster_str", [](KernelProfile& self) { return self.cluster_str; }, R"(
Returns the cluster dimensions as a string.
)");
  kernel_prof.def_prop_ro(
      "shared_mem_str",
      [](KernelProfile& self) { return self.shared_mem_str; },
      R"(
Returns the shared memory usage as a string.
)");
  kernel_prof.def_prop_ro(
      "registers", [](KernelProfile& self) { return self.registers; }, R"(
Returns the number of registers used by the kernel.
)");
  kernel_prof.def_prop_ro(
      "input_bytes", [](KernelProfile& self) { return self.input_bytes; }, R"(
Returns the input bytes processed by the kernel.
)");
  kernel_prof.def_prop_ro(
      "output_bytes", [](KernelProfile& self) { return self.output_bytes; }, R"(
Returns the output bytes generated by the kernel.
)");
  kernel_prof.def_prop_ro(
      "scheduler", [](KernelProfile& self) { return self.scheduler; }, R"(
Returns the scheduler type used for the kernel.
)");

  nb::class_<FusionProfile> fusion_prof(nvfuser, "FusionProfile");
  kernel_prof.def("__repr__", [](KernelProfile& self) {
    std::stringstream ss;
    ss << self;
    return ss.str();
  });
  fusion_prof.def_prop_ro(
      "verbose", [](FusionProfile& self) { return self.verbose; }, R"(
Returns the verbosity of the fusion profile.
)");
  fusion_prof.def_prop_ro(
      "fusion_id", [](FusionProfile& self) { return self.fusion_id; }, R"(
Returns the fusion id of the fusion profile.
)");
  fusion_prof.def_prop_ro(
      "segments", [](FusionProfile& self) { return self.segments; }, R"(
Returns the segments in the fusion profile.
)");
  fusion_prof.def_prop_ro(
      "cuda_evt_time_ms",
      [](FusionProfile& self) { return self.cuda_evt_time_ms; },
      R"(
Returns the CUDA event time in milliseconds of the fusion profile.
)");
  fusion_prof.def_prop_ro(
      "host_time_ms", [](FusionProfile& self) { return self.host_time_ms; }, R"(
Returns the host time in milliseconds of the fusion profile.
)");
  fusion_prof.def_prop_ro(
      "compile_time_ms",
      [](FusionProfile& self) { return self.compile_time_ms; },
      R"(
Returns the compile time in milliseconds of the fusion profile.
)");
  fusion_prof.def_prop_ro(
      "kernel_time_ms",
      [](FusionProfile& self) { return self.kernel_time_ms; },
      R"(
Returns the kernel time in milliseconds of the fusion profile.
)");
  fusion_prof.def_prop_ro(
      "effective_bandwidth_gbs",
      [](FusionProfile& self) { return self.effective_bandwidth_gbs; },
      R"(
Returns the effective bandwidth in gigabytes per second of the fusion profile.
)");
  fusion_prof.def_prop_ro(
      "percentage_peak_bandwith",
      [](FusionProfile& self) { return self.percentage_peak_bandwidth; },
      R"(
Returns the percentage of peak bandwidth of the fusion profile.
)");
  fusion_prof.def_prop_ro(
      "input_bytes", [](FusionProfile& self) { return self.input_bytes; }, R"(
Returns the input bytes of the fusion profile.
)");
  fusion_prof.def_prop_ro(
      "output_bytes", [](FusionProfile& self) { return self.output_bytes; }, R"(
Returns the output bytes of the fusion profile.
)");
  fusion_prof.def_prop_ro(
      "kernel_profiles",
      [](FusionProfile& self) { return self.kernel_profiles; },
      R"(
Returns the kernel profiles of the fusion profile.
)");
}

const FusionProfile& get_fusion_profile() {
  const FusionProfile& profile = FusionProfiler::profile();
  NVF_ERROR(
      profile.fusion_id != -1,
      "Something went wrong with Fusion Profiling as an illegal fusion_id "
      "was returned!")
  NVF_ERROR(
      profile.segments > 0,
      "Something went wrong with Fusion Profiling as no kernel segments were "
      "profiled!")
  return profile;
}

class PythonProfiler {
 public:
  PythonProfiler(bool auto_scheduled = false)
      : auto_scheduled_(auto_scheduled) {}

  PythonProfiler* start() {
    ProfilerOptionsGuard::getCurOptions().set(ProfilerOption::Enable);
    if (!auto_scheduled_) {
      FusionProfiler::start();
      FusionProfiler::createSegments(1);
    }
    return this;
  }

  void stop() {
    if (!auto_scheduled_) {
      FusionProfiler::segment(0).scheduler("user");
      FusionProfiler::stop();
    }
    ProfilerOptionsGuard::getCurOptions().unset(ProfilerOption::Enable);
  }

 private:
  //! Automatically scheduled fusions use the FusionExecutorCache.
  //! The FusionExecutorCache will trigger FusionProfiler, if it is enabled.
  bool auto_scheduled_ = true;
};

void bindProfiler(nb::module_& nvfuser) {
  nb::class_<PythonProfiler> profiler(nvfuser, "PythonProfiler");
  profiler.def(nb::init<bool>(), nb::arg("auto_scheduled") = true, R"(
Create a new PythonProfiler.

Parameters
----------
auto_scheduled : bool, optional
    Whether the fusion is automatically scheduled.
)");
  profiler.def(
      "__enter__", &PythonProfiler::start, nb::rv_policy::reference_internal);
  profiler.def(
      "__exit__",
      [&](PythonProfiler& self,
          nb::handle exc_type,
          nb::handle exc_value,
          nb::handle traceback) { self.stop(); },
      nb::arg("type").none(),
      nb::arg("value").none(),
      nb::arg("traceback").none());
  profiler.def_prop_ro(
      "profile",
      [&](PythonProfiler& self) { return get_fusion_profile(); },
      nb::rv_policy::reference,
      R"(
Returns the FusionProfile for the profiled fusion.

Returns:
    FusionProfile
)");
  nvfuser.def(
      "get_fusion_profile",
      &get_fusion_profile,
      nb::rv_policy::reference,
      R"(
Returns the FusionProfile for the profiled fusion.

Returns:
    FusionProfile
)");
  nvfuser.def(
      "reset_profiler",
      &FusionProfiler::reset,
      R"(Resets FusionProfiler so it can be used again.)");
}

} // namespace

void bindProfile(nb::module_& nvfuser) {
  bindFusionProfile(nvfuser);
  bindProfiler(nvfuser);
}

} // namespace nvfuser::python
