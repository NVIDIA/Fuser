"""
nvfuser C API python binding
"""
from __future__ import annotations
import torch
import typing
__all__ = ['DataType', 'FusionCache', 'Scalar', 'Tensor', 'Vector', 'compute_contiguity', 'compute_tensor_descriptor', 'serialize']
class DataType:
    """
    Members:
    
      Double
    
      Float
    
      Half
    
      Int
    
      Int32
    
      Bool
    
      BFloat16
    
      ComplexFloat
    
      ComplexDouble
    
      Null
    """
    BFloat16: typing.ClassVar[DataType]  # value = <DataType.BFloat16: 3>
    Bool: typing.ClassVar[DataType]  # value = <DataType.Bool: 9>
    ComplexDouble: typing.ClassVar[DataType]  # value = <DataType.ComplexDouble: 10>
    ComplexFloat: typing.ClassVar[DataType]  # value = <DataType.ComplexFloat: 11>
    Double: typing.ClassVar[DataType]  # value = <DataType.Double: 0>
    Float: typing.ClassVar[DataType]  # value = <DataType.Float: 1>
    Half: typing.ClassVar[DataType]  # value = <DataType.Half: 2>
    Int: typing.ClassVar[DataType]  # value = <DataType.Int: 4>
    Int32: typing.ClassVar[DataType]  # value = <DataType.Int32: 5>
    Null: typing.ClassVar[DataType]  # value = <DataType.Null: 13>
    __members__: typing.ClassVar[dict[str, DataType]]  # value = {'Double': <DataType.Double: 0>, 'Float': <DataType.Float: 1>, 'Half': <DataType.Half: 2>, 'Int': <DataType.Int: 4>, 'Int32': <DataType.Int32: 5>, 'Bool': <DataType.Bool: 9>, 'BFloat16': <DataType.BFloat16: 3>, 'ComplexFloat': <DataType.ComplexFloat: 11>, 'ComplexDouble': <DataType.ComplexDouble: 10>, 'Null': <DataType.Null: 13>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class FusionCache:
    @staticmethod
    def get(max_fusions: int = 16384, selected_device: int | None = -1, load_from_default_workspace: bool = True) -> FusionCache:
        ...
    @staticmethod
    def reset() -> None:
        ...
    def __repr__(self) -> str:
        ...
    def deserialize(self, filename: str) -> None:
        ...
    def num_fusions(self) -> int:
        ...
    def serialize(self, filename: str) -> None:
        ...
    def stats(self) -> str:
        ...
class Scalar:
    __hash__: typing.ClassVar[None] = None
    def __abs__(self) -> Scalar:
        ...
    @typing.overload
    def __add__(self, arg0: Tensor) -> Tensor:
        ...
    @typing.overload
    def __add__(self, arg0: Scalar) -> Scalar:
        ...
    @typing.overload
    def __and__(self, arg0: Tensor) -> Tensor:
        ...
    @typing.overload
    def __and__(self, arg0: Scalar) -> Scalar:
        ...
    @typing.overload
    def __eq__(self, arg0: Tensor) -> Tensor:
        ...
    @typing.overload
    def __eq__(self, arg0: Scalar) -> Scalar:
        ...
    @typing.overload
    def __ge__(self, arg0: Tensor) -> Tensor:
        ...
    @typing.overload
    def __ge__(self, arg0: Scalar) -> Scalar:
        ...
    @typing.overload
    def __gt__(self, arg0: Tensor) -> Tensor:
        ...
    @typing.overload
    def __gt__(self, arg0: Scalar) -> Scalar:
        ...
    @typing.overload
    def __le__(self, arg0: Tensor) -> Tensor:
        ...
    @typing.overload
    def __le__(self, arg0: Scalar) -> Scalar:
        ...
    @typing.overload
    def __lshift__(self, arg0: Tensor) -> Tensor:
        ...
    @typing.overload
    def __lshift__(self, arg0: Scalar) -> Scalar:
        ...
    @typing.overload
    def __lt__(self, arg0: Tensor) -> Tensor:
        ...
    @typing.overload
    def __lt__(self, arg0: Scalar) -> Scalar:
        ...
    @typing.overload
    def __mod__(self, arg0: Tensor) -> Tensor:
        ...
    @typing.overload
    def __mod__(self, arg0: Scalar) -> Scalar:
        ...
    @typing.overload
    def __mul__(self, arg0: Tensor) -> Tensor:
        ...
    @typing.overload
    def __mul__(self, arg0: Scalar) -> Scalar:
        ...
    @typing.overload
    def __ne__(self, arg0: Tensor) -> Tensor:
        ...
    @typing.overload
    def __ne__(self, arg0: Scalar) -> Scalar:
        ...
    def __neg__(self) -> Scalar:
        ...
    @typing.overload
    def __or__(self, arg0: Tensor) -> Tensor:
        ...
    @typing.overload
    def __or__(self, arg0: Scalar) -> Scalar:
        ...
    @typing.overload
    def __pow__(self, arg0: Tensor) -> Tensor:
        ...
    @typing.overload
    def __pow__(self, arg0: Scalar) -> Scalar:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rshift__(self, arg0: Tensor) -> Tensor:
        ...
    @typing.overload
    def __rshift__(self, arg0: Scalar) -> Scalar:
        ...
    @typing.overload
    def __sub__(self, arg0: Tensor) -> Tensor:
        ...
    @typing.overload
    def __sub__(self, arg0: Scalar) -> Scalar:
        ...
    @typing.overload
    def __truediv__(self, arg0: Tensor) -> Tensor:
        ...
    @typing.overload
    def __truediv__(self, arg0: Scalar) -> Scalar:
        ...
    @typing.overload
    def __xor__(self, arg0: Tensor) -> Tensor:
        ...
    @typing.overload
    def __xor__(self, arg0: Scalar) -> Scalar:
        ...
class Tensor:
    __hash__: typing.ClassVar[None] = None
    def __abs__(self) -> Tensor:
        ...
    @typing.overload
    def __add__(self, arg0: Tensor) -> Tensor:
        ...
    @typing.overload
    def __add__(self, arg0: Scalar) -> Tensor:
        ...
    @typing.overload
    def __and__(self, arg0: Tensor) -> Tensor:
        ...
    @typing.overload
    def __and__(self, arg0: Scalar) -> Tensor:
        ...
    @typing.overload
    def __eq__(self, arg0: Tensor) -> Tensor:
        ...
    @typing.overload
    def __eq__(self, arg0: Scalar) -> Tensor:
        ...
    @typing.overload
    def __ge__(self, arg0: Tensor) -> Tensor:
        ...
    @typing.overload
    def __ge__(self, arg0: Scalar) -> Tensor:
        ...
    @typing.overload
    def __gt__(self, arg0: Tensor) -> Tensor:
        ...
    @typing.overload
    def __gt__(self, arg0: Scalar) -> Tensor:
        ...
    @typing.overload
    def __le__(self, arg0: Tensor) -> Tensor:
        ...
    @typing.overload
    def __le__(self, arg0: Scalar) -> Tensor:
        ...
    @typing.overload
    def __lshift__(self, arg0: Tensor) -> Tensor:
        ...
    @typing.overload
    def __lshift__(self, arg0: Scalar) -> Tensor:
        ...
    @typing.overload
    def __lt__(self, arg0: Tensor) -> Tensor:
        ...
    @typing.overload
    def __lt__(self, arg0: Scalar) -> Tensor:
        ...
    @typing.overload
    def __mod__(self, arg0: Tensor) -> Tensor:
        ...
    @typing.overload
    def __mod__(self, arg0: Scalar) -> Tensor:
        ...
    @typing.overload
    def __mul__(self, arg0: Tensor) -> Tensor:
        ...
    @typing.overload
    def __mul__(self, arg0: Scalar) -> Tensor:
        ...
    @typing.overload
    def __ne__(self, arg0: Tensor) -> Tensor:
        ...
    @typing.overload
    def __ne__(self, arg0: Scalar) -> Tensor:
        ...
    def __neg__(self) -> Tensor:
        ...
    @typing.overload
    def __or__(self, arg0: Tensor) -> Tensor:
        ...
    @typing.overload
    def __or__(self, arg0: Scalar) -> Tensor:
        ...
    @typing.overload
    def __pow__(self, arg0: Tensor) -> Tensor:
        ...
    @typing.overload
    def __pow__(self, arg0: Scalar) -> Tensor:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rshift__(self, arg0: Tensor) -> Tensor:
        ...
    @typing.overload
    def __rshift__(self, arg0: Scalar) -> Tensor:
        ...
    @typing.overload
    def __sub__(self, arg0: Tensor) -> Tensor:
        ...
    @typing.overload
    def __sub__(self, arg0: Scalar) -> Tensor:
        ...
    @typing.overload
    def __truediv__(self, arg0: Tensor) -> Tensor:
        ...
    @typing.overload
    def __truediv__(self, arg0: Scalar) -> Tensor:
        ...
    @typing.overload
    def __xor__(self, arg0: Tensor) -> Tensor:
        ...
    @typing.overload
    def __xor__(self, arg0: Scalar) -> Tensor:
        ...
    def _get_fusion_definition(self) -> ...:
        ...
    def shape(self) -> Vector:
        ...
    def size(self, arg0: int) -> Scalar:
        ...
    @property
    def ndim(self) -> int:
        ...
class Vector:
    def __getitem__(self, arg0: int) -> Scalar:
        ...
    def __repr__(self) -> str:
        ...
    def at(self, arg0: int) -> Scalar:
        ...
    @property
    def size(self) -> int:
        ...
class _FusionDefinition:
    class Operators:
        def __init__(self, arg0: _FusionDefinition) -> None:
            ...
        def _matmul_nn(self, arg0: Tensor, arg1: Tensor) -> Tensor:
            ...
        def _matmul_nt(self, arg0: Tensor, arg1: Tensor) -> Tensor:
            ...
        def _matmul_tn(self, arg0: Tensor, arg1: Tensor) -> Tensor:
            ...
        def _matmul_tt(self, arg0: Tensor, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def abs(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def abs(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def acos(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def acos(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def acosh(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def acosh(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def add(self, arg0: Tensor, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def add(self, arg0: Tensor, arg1: Scalar) -> Tensor:
            ...
        @typing.overload
        def add(self, arg0: Scalar, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def add(self, arg0: Scalar, arg1: Scalar) -> Scalar:
            ...
        @typing.overload
        def add_alpha(self, arg0: Tensor, arg1: Tensor, arg2: Scalar) -> Tensor:
            ...
        @typing.overload
        def add_alpha(self, arg0: Tensor, arg1: Scalar, arg2: Scalar) -> Tensor:
            ...
        @typing.overload
        def add_alpha(self, arg0: Scalar, arg1: Tensor, arg2: Scalar) -> Tensor:
            ...
        @typing.overload
        def add_alpha(self, arg0: Scalar, arg1: Scalar, arg2: Scalar) -> Scalar:
            ...
        @typing.overload
        def addcmul(self, arg0: Scalar, arg1: Scalar, arg2: Scalar, arg3: Scalar) -> Scalar:
            ...
        @typing.overload
        def addcmul(self, arg0: Tensor, arg1: Tensor, arg2: Tensor, arg3: Scalar) -> Tensor:
            ...
        @typing.overload
        def addcmul(self, arg0: Tensor, arg1: Tensor, arg2: Scalar, arg3: Scalar) -> Tensor:
            ...
        @typing.overload
        def addcmul(self, arg0: Tensor, arg1: Scalar, arg2: Tensor, arg3: Scalar) -> Tensor:
            ...
        @typing.overload
        def addcmul(self, arg0: Scalar, arg1: Tensor, arg2: Tensor, arg3: Scalar) -> Tensor:
            ...
        @typing.overload
        def addcmul(self, arg0: Scalar, arg1: Scalar, arg2: Tensor, arg3: Scalar) -> Tensor:
            ...
        @typing.overload
        def addcmul(self, arg0: Tensor, arg1: Scalar, arg2: Scalar, arg3: Scalar) -> Tensor:
            ...
        @typing.overload
        def addcmul(self, arg0: Scalar, arg1: Tensor, arg2: Scalar, arg3: Scalar) -> Tensor:
            ...
        @typing.overload
        def asin(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def asin(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def asinh(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def asinh(self, arg0: Scalar) -> Scalar:
            ...
        def at(self, arg: Vector, index: int) -> Scalar:
            ...
        @typing.overload
        def atan(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def atan(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def atan2(self, arg0: Tensor, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def atan2(self, arg0: Tensor, arg1: Scalar) -> Tensor:
            ...
        @typing.overload
        def atan2(self, arg0: Scalar, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def atan2(self, arg0: Scalar, arg1: Scalar) -> Scalar:
            ...
        @typing.overload
        def atanh(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def atanh(self, arg0: Scalar) -> Scalar:
            ...
        def batch_norm(self, arg: Tensor, weight: Tensor | None, bias: Tensor | None, running_mean: Tensor | None, running_var: Tensor | None, momentum: Scalar, eps: Scalar, training: bool, channels_last: bool = False) -> tuple[Tensor, Tensor, Tensor]:
            ...
        @typing.overload
        def bitwise_and(self, arg0: Tensor, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def bitwise_and(self, arg0: Tensor, arg1: Scalar) -> Tensor:
            ...
        @typing.overload
        def bitwise_and(self, arg0: Scalar, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def bitwise_and(self, arg0: Scalar, arg1: Scalar) -> Scalar:
            ...
        @typing.overload
        def bitwise_left_shift(self, arg0: Tensor, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def bitwise_left_shift(self, arg0: Tensor, arg1: Scalar) -> Tensor:
            ...
        @typing.overload
        def bitwise_left_shift(self, arg0: Scalar, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def bitwise_left_shift(self, arg0: Scalar, arg1: Scalar) -> Scalar:
            ...
        @typing.overload
        def bitwise_not(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def bitwise_not(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def bitwise_or(self, arg0: Tensor, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def bitwise_or(self, arg0: Tensor, arg1: Scalar) -> Tensor:
            ...
        @typing.overload
        def bitwise_or(self, arg0: Scalar, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def bitwise_or(self, arg0: Scalar, arg1: Scalar) -> Scalar:
            ...
        @typing.overload
        def bitwise_right_shift(self, arg0: Tensor, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def bitwise_right_shift(self, arg0: Tensor, arg1: Scalar) -> Tensor:
            ...
        @typing.overload
        def bitwise_right_shift(self, arg0: Scalar, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def bitwise_right_shift(self, arg0: Scalar, arg1: Scalar) -> Scalar:
            ...
        @typing.overload
        def bitwise_xor(self, arg0: Tensor, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def bitwise_xor(self, arg0: Tensor, arg1: Scalar) -> Tensor:
            ...
        @typing.overload
        def bitwise_xor(self, arg0: Scalar, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def bitwise_xor(self, arg0: Scalar, arg1: Scalar) -> Scalar:
            ...
        def broadcast(self, arg: Tensor, is_broadcast_dim: list[bool]) -> Tensor:
            ...
        @typing.overload
        def broadcast_in_dim(self, arg: Tensor, shape: Vector, broadcast_dims: list[int]) -> Tensor:
            ...
        @typing.overload
        def broadcast_in_dim(self, arg: Tensor, shape: list, broadcast_dims: list[int]) -> Tensor:
            ...
        @typing.overload
        def broadcast_in_dim(self, arg: Tensor, shape: tuple, broadcast_dims: list[int]) -> Tensor:
            ...
        @typing.overload
        def cast(self, arg: Tensor, dtype: DataType) -> Tensor:
            ...
        @typing.overload
        def cast(self, arg: Scalar, dtype: DataType) -> Scalar:
            ...
        def cat(self, tensors: list[Tensor], dim: int = 0) -> Tensor:
            ...
        @typing.overload
        def ceil(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def ceil(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def clamp(self, arg0: Scalar, arg1: Scalar, arg2: Scalar) -> Scalar:
            ...
        @typing.overload
        def clamp(self, arg0: Tensor, arg1: Scalar, arg2: Scalar) -> Tensor:
            ...
        @typing.overload
        def cos(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def cos(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def cosh(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def cosh(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def div(self, arg0: Tensor, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def div(self, arg0: Tensor, arg1: Scalar) -> Tensor:
            ...
        @typing.overload
        def div(self, arg0: Scalar, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def div(self, arg0: Scalar, arg1: Scalar) -> Scalar:
            ...
        @typing.overload
        def eq(self, arg0: Tensor, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def eq(self, arg0: Tensor, arg1: Scalar) -> Tensor:
            ...
        @typing.overload
        def eq(self, arg0: Scalar, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def eq(self, arg0: Scalar, arg1: Scalar) -> Scalar:
            ...
        @typing.overload
        def erf(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def erf(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def erfc(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def erfc(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def erfcinv(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def erfcinv(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def erfinv(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def erfinv(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def exp(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def exp(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def exp2(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def exp2(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def expm1(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def expm1(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def floor(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def floor(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def fmod(self, arg0: Tensor, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def fmod(self, arg0: Tensor, arg1: Scalar) -> Tensor:
            ...
        @typing.overload
        def fmod(self, arg0: Scalar, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def fmod(self, arg0: Scalar, arg1: Scalar) -> Scalar:
            ...
        @typing.overload
        def frac(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def frac(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def full(self, shape: Vector, fill_value: Scalar, dtype: DataType) -> Tensor:
            ...
        @typing.overload
        def full(self, shape: list, fill_value: Scalar, dtype: DataType) -> Tensor:
            ...
        @typing.overload
        def full(self, shape: tuple, fill_value: Scalar, dtype: DataType) -> Tensor:
            ...
        def gather(self, arg1: Tensor, index: Tensor, dim: int) -> Tensor:
            """
                    Index arg1 in dim at positions given by index.
            
                    The dimension of arg1 and index must match. For all axes other than dim
                    the extent of index in that axis need not be equal to its counterpart
                    in arg1 but must not be greater than it.
            
                    Args:
                        arg1 (Tensor): Tensor of shape `(Ni...,M,Nk...)` where `M` is the
                            extent of `arg1` in the dimension `dim`.
                        index (Tensor): Tensor of dtype `DataType::Int` of shape
                            `(Mi...,J,Mk...)` where all the extents other than `J` are less
                            than or equal to their counterparts in `arg1`; for example `Mk
                            <= Nk`.
                        dim (int): Which position to index along.
            
                    Returns:
                        (Tensor): Tensor of same dtype as `arg1` and of shape
                            `(Mi...,J,Mk...)` where the element at position `(i...,j,k...)`
                            is equal to `arg1[i,...,index[i,...,j,k,...],k,...]`.
            """
        @typing.overload
        def gcd(self, arg0: Tensor, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def gcd(self, arg0: Tensor, arg1: Scalar) -> Tensor:
            ...
        @typing.overload
        def gcd(self, arg0: Scalar, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def gcd(self, arg0: Scalar, arg1: Scalar) -> Scalar:
            ...
        @typing.overload
        def ge(self, arg0: Tensor, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def ge(self, arg0: Tensor, arg1: Scalar) -> Tensor:
            ...
        @typing.overload
        def ge(self, arg0: Scalar, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def ge(self, arg0: Scalar, arg1: Scalar) -> Scalar:
            ...
        @typing.overload
        def gt(self, arg0: Tensor, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def gt(self, arg0: Tensor, arg1: Scalar) -> Tensor:
            ...
        @typing.overload
        def gt(self, arg0: Scalar, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def gt(self, arg0: Scalar, arg1: Scalar) -> Scalar:
            ...
        @typing.overload
        def imag(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def imag(self, arg0: Scalar) -> Scalar:
            ...
        def index_select(self, arg: Tensor, index: Tensor, dim: int) -> Tensor:
            ...
        def iota(self, length: Scalar, start: Scalar | None, step: Scalar | None, dtype: DataType = ...) -> Tensor:
            ...
        @typing.overload
        def isfinite(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def isfinite(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def isinf(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def isinf(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def isnan(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def isnan(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def isneginf(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def isneginf(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def isposinf(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def isposinf(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def isreal(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def isreal(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def le(self, arg0: Tensor, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def le(self, arg0: Tensor, arg1: Scalar) -> Tensor:
            ...
        @typing.overload
        def le(self, arg0: Scalar, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def le(self, arg0: Scalar, arg1: Scalar) -> Scalar:
            ...
        @typing.overload
        def lerp(self, arg0: Scalar, arg1: Scalar, arg2: Scalar) -> Scalar:
            ...
        @typing.overload
        def lerp(self, arg0: Tensor, arg1: Tensor, arg2: Tensor) -> Tensor:
            ...
        @typing.overload
        def lerp(self, arg0: Tensor, arg1: Tensor, arg2: Scalar) -> Tensor:
            ...
        @typing.overload
        def lerp(self, arg0: Tensor, arg1: Scalar, arg2: Tensor) -> Tensor:
            ...
        @typing.overload
        def lerp(self, arg0: Scalar, arg1: Tensor, arg2: Tensor) -> Tensor:
            ...
        @typing.overload
        def lerp(self, arg0: Scalar, arg1: Scalar, arg2: Tensor) -> Tensor:
            ...
        @typing.overload
        def lerp(self, arg0: Tensor, arg1: Scalar, arg2: Scalar) -> Tensor:
            ...
        @typing.overload
        def lerp(self, arg0: Scalar, arg1: Tensor, arg2: Scalar) -> Tensor:
            ...
        @typing.overload
        def lgamma(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def lgamma(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def log(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def log(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def log10(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def log10(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def log1p(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def log1p(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def log2(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def log2(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def logical_and(self, arg0: Tensor, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def logical_and(self, arg0: Tensor, arg1: Scalar) -> Tensor:
            ...
        @typing.overload
        def logical_and(self, arg0: Scalar, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def logical_and(self, arg0: Scalar, arg1: Scalar) -> Scalar:
            ...
        @typing.overload
        def logical_not(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def logical_not(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def logical_or(self, arg0: Tensor, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def logical_or(self, arg0: Tensor, arg1: Scalar) -> Tensor:
            ...
        @typing.overload
        def logical_or(self, arg0: Scalar, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def logical_or(self, arg0: Scalar, arg1: Scalar) -> Scalar:
            ...
        @typing.overload
        def logical_right_shift(self, arg0: Tensor, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def logical_right_shift(self, arg0: Tensor, arg1: Scalar) -> Tensor:
            ...
        @typing.overload
        def logical_right_shift(self, arg0: Scalar, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def logical_right_shift(self, arg0: Scalar, arg1: Scalar) -> Scalar:
            ...
        @typing.overload
        def lt(self, arg0: Tensor, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def lt(self, arg0: Tensor, arg1: Scalar) -> Tensor:
            ...
        @typing.overload
        def lt(self, arg0: Scalar, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def lt(self, arg0: Scalar, arg1: Scalar) -> Scalar:
            ...
        @typing.overload
        def max(self, arg: Tensor, dtype: DataType = ...) -> Tensor:
            ...
        @typing.overload
        def max(self, arg: Tensor, axis: int, keepdim: bool = False, dtype: DataType = ...) -> Tensor:
            ...
        @typing.overload
        def max(self, arg: Tensor, axes: list[int], keepdim: bool = False, dtype: DataType = ...) -> Tensor:
            ...
        @typing.overload
        def min(self, arg: Tensor, dtype: DataType = ...) -> Tensor:
            ...
        @typing.overload
        def min(self, arg: Tensor, axis: int, keepdim: bool = False, dtype: DataType = ...) -> Tensor:
            ...
        @typing.overload
        def min(self, arg: Tensor, axes: list[int], keepdim: bool = False, dtype: DataType = ...) -> Tensor:
            ...
        @typing.overload
        def mod(self, arg0: Tensor, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def mod(self, arg0: Tensor, arg1: Scalar) -> Tensor:
            ...
        @typing.overload
        def mod(self, arg0: Scalar, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def mod(self, arg0: Scalar, arg1: Scalar) -> Scalar:
            ...
        @typing.overload
        def mul(self, arg0: Tensor, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def mul(self, arg0: Tensor, arg1: Scalar) -> Tensor:
            ...
        @typing.overload
        def mul(self, arg0: Scalar, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def mul(self, arg0: Scalar, arg1: Scalar) -> Scalar:
            ...
        @typing.overload
        def ne(self, arg0: Tensor, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def ne(self, arg0: Tensor, arg1: Scalar) -> Tensor:
            ...
        @typing.overload
        def ne(self, arg0: Scalar, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def ne(self, arg0: Scalar, arg1: Scalar) -> Scalar:
            ...
        @typing.overload
        def neg(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def neg(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def nextafter(self, arg0: Tensor, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def nextafter(self, arg0: Tensor, arg1: Scalar) -> Tensor:
            ...
        @typing.overload
        def nextafter(self, arg0: Scalar, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def nextafter(self, arg0: Scalar, arg1: Scalar) -> Scalar:
            ...
        @typing.overload
        def normal(self, mean: Scalar, std: Scalar, shape: Vector, *, rng_seed: Scalar | None = None, rng_offset: Scalar | None = None, dtype: DataType = ...) -> Tensor:
            ...
        @typing.overload
        def normal(self, mean: Scalar, std: Scalar, shape: list, *, rng_seed: Scalar | None = None, rng_offset: Scalar | None = None, dtype: DataType = ...) -> Tensor:
            ...
        @typing.overload
        def normal(self, mean: Scalar, std: Scalar, shape: tuple, *, rng_seed: Scalar | None = None, rng_offset: Scalar | None = None, dtype: DataType = ...) -> Tensor:
            ...
        def pad(self, arg: Tensor, pad_widths: list[int], value: Scalar | None = None) -> Tensor:
            ...
        def permute(self, arg: Tensor, dims: list[int]) -> Tensor:
            ...
        @typing.overload
        def pow(self, arg0: Tensor, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def pow(self, arg0: Tensor, arg1: Scalar) -> Tensor:
            ...
        @typing.overload
        def pow(self, arg0: Scalar, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def pow(self, arg0: Scalar, arg1: Scalar) -> Scalar:
            ...
        @typing.overload
        def prod(self, arg: Tensor, dtype: DataType = ...) -> Tensor:
            ...
        @typing.overload
        def prod(self, arg: Tensor, axis: int, keepdim: bool = False, dtype: DataType = ...) -> Tensor:
            ...
        @typing.overload
        def prod(self, arg: Tensor, axes: list[int], keepdim: bool = False, dtype: DataType = ...) -> Tensor:
            ...
        @typing.overload
        def rand_like(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def rand_like(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def rand_like(self, arg: Tensor, *, rng_seed: Scalar, rng_offset: Scalar) -> Tensor:
            ...
        @typing.overload
        def randn_like(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def randn_like(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def randn_like(self, arg: Tensor, *, rng_seed: Scalar, rng_offset: Scalar) -> Tensor:
            ...
        @typing.overload
        def real(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def real(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def reciprocal(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def reciprocal(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def relu(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def relu(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def remainder(self, arg0: Tensor, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def remainder(self, arg0: Tensor, arg1: Scalar) -> Tensor:
            ...
        @typing.overload
        def remainder(self, arg0: Scalar, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def remainder(self, arg0: Scalar, arg1: Scalar) -> Scalar:
            ...
        @typing.overload
        def reshape(self, arg: Tensor, new_shape: Vector) -> Tensor:
            ...
        @typing.overload
        def reshape(self, arg: Tensor, new_shape: list) -> Tensor:
            ...
        @typing.overload
        def reshape(self, arg: Tensor, new_shape: tuple) -> Tensor:
            ...
        @typing.overload
        def round(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def round(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def rsqrt(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def rsqrt(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def segment_set(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def segment_set(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def set(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def set(self, arg0: Scalar) -> Scalar:
            ...
        def shape(self, arg: Tensor) -> Vector:
            ...
        @typing.overload
        def sigmoid(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def sigmoid(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def sign(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def sign(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def signbit(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def signbit(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def silu(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def silu(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def sin(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def sin(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def sinh(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def sinh(self, arg0: Scalar) -> Scalar:
            ...
        def size(self, arg: Tensor, dim: int) -> Scalar:
            ...
        def slice(self, arg: Tensor, start_indices: list[int], end_indices: list[int], strides: list[int] | None = None) -> Tensor:
            ...
        @typing.overload
        def sqrt(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def sqrt(self, arg0: Scalar) -> Scalar:
            ...
        def squeeze(self, arg: Tensor, dims: list[int]) -> Tensor:
            ...
        def stride_order(self, arg: Tensor, stride_order: list[int]) -> Tensor:
            ...
        @typing.overload
        def sub(self, arg0: Tensor, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def sub(self, arg0: Tensor, arg1: Scalar) -> Tensor:
            ...
        @typing.overload
        def sub(self, arg0: Scalar, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def sub(self, arg0: Scalar, arg1: Scalar) -> Scalar:
            ...
        @typing.overload
        def sub_alpha(self, arg0: Tensor, arg1: Tensor, arg2: Scalar) -> Tensor:
            ...
        @typing.overload
        def sub_alpha(self, arg0: Tensor, arg1: Scalar, arg2: Scalar) -> Tensor:
            ...
        @typing.overload
        def sub_alpha(self, arg0: Scalar, arg1: Tensor, arg2: Scalar) -> Tensor:
            ...
        @typing.overload
        def sub_alpha(self, arg0: Scalar, arg1: Scalar, arg2: Scalar) -> Scalar:
            ...
        @typing.overload
        def sum(self, arg: Tensor, dtype: DataType = ...) -> Tensor:
            ...
        @typing.overload
        def sum(self, arg: Tensor, axis: int, keepdim: bool = False, dtype: DataType = ...) -> Tensor:
            ...
        @typing.overload
        def sum(self, arg: Tensor, axes: list[int], keepdim: bool = False, dtype: DataType = ...) -> Tensor:
            ...
        def take_along_axis(self, arg1: Tensor, index: Tensor, dim: int) -> Tensor:
            """
                    Index arg1 in dim at positions given by index.
            
                    This operation is very similar to :meth:'gather' but enforces that all
                    dimensions other than dim must be equal between arg1 and index.
            
                    Args:
                        arg1 (Tensor): Tensor of shape `(Ni...,M,Nk...)` where `M` is the
                            extent of `arg1` in the dimension `dim`.
                        index (Tensor): Tensor of dtype `DataType::Int` of shape
                            `(Ni...,J,Nk...)`.
                        dim (int): Which position to index along.
            
                    Returns:
                        (Tensor): Tensor of same dtype as `arg1` and of shape
                            `(Ni...,J,Nk...)` where the element at position `(i...,j,k...)`
                            is equal to `arg1[i,...,index[i,...,j,k,...],k,...]`.
            """
        @typing.overload
        def tan(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def tan(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def tanh(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def tanh(self, arg0: Scalar) -> Scalar:
            ...
        def tensor_sizes(self, arg: Tensor) -> list[Scalar]:
            ...
        @typing.overload
        def threshold(self, arg0: Scalar, arg1: Scalar, arg2: Scalar) -> Scalar:
            ...
        @typing.overload
        def threshold(self, arg0: Tensor, arg1: Scalar, arg2: Scalar) -> Tensor:
            ...
        @typing.overload
        def truediv(self, arg0: Tensor, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def truediv(self, arg0: Tensor, arg1: Scalar) -> Tensor:
            ...
        @typing.overload
        def truediv(self, arg0: Scalar, arg1: Tensor) -> Tensor:
            ...
        @typing.overload
        def truediv(self, arg0: Scalar, arg1: Scalar) -> Scalar:
            ...
        @typing.overload
        def trunc(self, arg0: Tensor) -> Tensor:
            ...
        @typing.overload
        def trunc(self, arg0: Scalar) -> Scalar:
            ...
        @typing.overload
        def uniform(self, minval: Scalar, maxval: Scalar, shape: Vector, *, rng_seed: Scalar | None = None, rng_offset: Scalar | None = None, dtype: DataType = ...) -> Tensor:
            ...
        @typing.overload
        def uniform(self, minval: Scalar, maxval: Scalar, shape: list, *, rng_seed: Scalar | None = None, rng_offset: Scalar | None = None, dtype: DataType = ...) -> Tensor:
            ...
        @typing.overload
        def uniform(self, minval: Scalar, maxval: Scalar, shape: tuple, *, rng_seed: Scalar | None = None, rng_offset: Scalar | None = None, dtype: DataType = ...) -> Tensor:
            ...
        def var(self, arg: Tensor, axes: list[int], correction: int, keepdim: bool = False) -> Tensor:
            ...
        def var_mean(self, arg: Tensor, axes: list[int], correction: int = 1, keepdim: bool = False) -> tuple[Tensor, Tensor]:
            ...
        @typing.overload
        def where(self, arg0: Scalar, arg1: Scalar, arg2: Scalar) -> Scalar:
            ...
        @typing.overload
        def where(self, arg0: Tensor, arg1: Tensor, arg2: Tensor) -> Tensor:
            ...
        @typing.overload
        def where(self, arg0: Tensor, arg1: Tensor, arg2: Scalar) -> Tensor:
            ...
        @typing.overload
        def where(self, arg0: Tensor, arg1: Scalar, arg2: Tensor) -> Tensor:
            ...
        @typing.overload
        def where(self, arg0: Scalar, arg1: Tensor, arg2: Tensor) -> Tensor:
            ...
        @typing.overload
        def where(self, arg0: Scalar, arg1: Scalar, arg2: Tensor) -> Tensor:
            ...
        @typing.overload
        def where(self, arg0: Tensor, arg1: Scalar, arg2: Scalar) -> Tensor:
            ...
        @typing.overload
        def where(self, arg0: Scalar, arg1: Tensor, arg2: Scalar) -> Tensor:
            ...
    class SchedOperators:
        def __init__(self, arg0: _FusionDefinition) -> None:
            ...
        def merge(self, arg: Tensor, dim: int) -> None:
            ...
        def reduction_factor(self, arg: Tensor, dims: list[int]) -> Tensor:
            ...
        def reorder(self, arg: Tensor, old2new: dict[int, int]) -> None:
            ...
        def rfactor(self, arg: Tensor, dims: list[int]) -> Tensor:
            ...
        def split(self, arg: Tensor, dim: int, factor: int, inner_split: bool = True, trim_out_of_bounds: bool = False) -> None:
            ...
    ops: ...
    sched: ...
    def __init__(self, id: int | None = None, max_length: int = 1024) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def _cuda_code_for(self, inputs: typing.Iterable, intrinsic_code: bool = False, override_user_schedule: bool = False) -> str:
        ...
    def _debug_output(self) -> str | None:
        ...
    def _execute(self, inputs: typing.Iterable, override_user_schedule: bool = False, *, device: int | None = None, capture_debug_output: bool = False) -> list[torch.Tensor]:
        ...
    def _finalize_definition(self) -> None:
        ...
    def _finalize_schedule(self, arg0: typing.Iterable) -> None:
        ...
    def _fusion_ir(self) -> str:
        ...
    def _last_cuda_code(self, intrinsic_code: bool = False, override_user_schedule: bool = False) -> str:
        ...
    def _last_scheduled_fusion_ir(self, tensor_transforms: bool = False, override_user_schedule: bool = False) -> str:
        ...
    def _scheduled_fusion_ir_for(self, inputs: typing.Iterable, tensor_transforms: bool = False, override_user_schedule: bool = False) -> str:
        ...
    def _setup_definition(self) -> _FusionDefinition:
        ...
    def _setup_schedule(self, arg0: typing.Iterable) -> None:
        ...
    @typing.overload
    def add_output(self, output: Scalar) -> None:
        ...
    @typing.overload
    def add_output(self, output: Tensor, alias_input: Tensor | None = None) -> None:
        ...
    @typing.overload
    def add_output(self, output: Tensor, stride_order: list[int]) -> None:
        ...
    def define_constant(self, value: None | ... | ... | ... | torch.Tensor | complex | float | int | bool | list[..., ..., ..., ..., ..., ..., double, long, ...], dtype: DataType | None = None) -> Scalar:
        ...
    @typing.overload
    def define_scalar(self, dtype: DataType = ...) -> Scalar:
        ...
    @typing.overload
    def define_scalar(self, value: None | ... | ... | ... | torch.Tensor | complex | float | int | bool | list[..., ..., ..., ..., ..., ..., double, long, ...], dtype: DataType | None = None) -> Scalar:
        ...
    @typing.overload
    def define_tensor(self, shape: list[int], contiguity: list[bool | None], dtype: DataType = ..., is_cpu: bool = False, stride_order: list[int] = []) -> Tensor:
        ...
    @typing.overload
    def define_tensor(self, sizes: list[int], strides: list[int], dtype: DataType = ..., static_sizes: bool = False, is_cpu: bool = False) -> Tensor:
        ...
    @typing.overload
    def define_vector(self, size: int) -> Vector:
        ...
    @typing.overload
    def define_vector(self, values: list, dtype: DataType = ...) -> Vector:
        ...
    @typing.overload
    def define_vector(self, values: tuple, dtype: DataType = ...) -> Vector:
        ...
    def getValTolerances(self, arg0: typing.Iterable) -> list[tuple[float, float]]:
        ...
    def id(self) -> int | None:
        ...
def compute_contiguity(arg0: list[int], arg1: list[int]) -> list[bool | None]:
    ...
def compute_tensor_descriptor(arg0: list[int], arg1: list[int]) -> tuple[list[bool | None], list[int]]:
    ...
def serialize() -> None:
    ...
