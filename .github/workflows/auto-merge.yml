# SPDX-FileCopyrightText: Copyright (c) 2023-present NVIDIA CORPORATION & AFFILIATES.
# All rights reserved.
# SPDX-License-Identifier: BSD-3-Clause

# Auto-merge PRs when all CI checks pass and the "enable-auto-merge" label is present
name: Auto-merge PR
on:
  pull_request:
    types:
      - labeled
      - synchronize
      - reopened
  pull_request_review:
    types:
      - submitted
  check_run:
    types:
      - completed
  status: {}

jobs:
  auto-merge:
    name: Auto-merge PR
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      statuses: read
      checks: read

    # Only run if conditions are met based on event type
    if: |
      (github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'enable-auto-merge')) ||
      (github.event_name == 'pull_request_review' && github.event.review.state == 'approved' && contains(github.event.pull_request.labels.*.name, 'enable-auto-merge')) ||
      (github.event_name == 'check_run' && github.event.check_run.conclusion == 'success') ||
      (github.event_name == 'status' && github.event.state == 'success')

    steps:
      - name: Get PR details
        id: pr
        uses: actions/github-script@v7
        with:
          script: |
            let pr;
            if (context.payload.pull_request) {
              pr = context.payload.pull_request;
            } else {
              // For status/check_run events, we need to find the PR
              const prs = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                head: `${context.repo.owner}:${context.payload.check_run?.head_branch || context.payload.branches?.[0]?.name}`,
              });

              if (prs.data.length === 0) {
                core.info('No open PR found for this commit');
                return { should_skip: true };
              }

              pr = prs.data[0];
            }

            // Check if PR has the enable-auto-merge label
            const hasLabel = pr.labels.some(label => label.name === 'enable-auto-merge');
            if (!hasLabel) {
              core.info('PR does not have enable-auto-merge label');
              return { should_skip: true };
            }

            return {
              should_skip: false,
              number: pr.number,
              sha: pr.head.sha,
              mergeable: pr.mergeable,
              mergeable_state: pr.mergeable_state,
            };

      - name: Check PR can be processed
        if: steps.pr.outputs.result != 'null'
        run: |
          PR_DATA='${{ steps.pr.outputs.result }}'
          SHOULD_SKIP=$(echo "$PR_DATA" | jq -r '.should_skip')

          if [ "$SHOULD_SKIP" = "true" ]; then
            echo "Skipping auto-merge for this event"
            exit 0
          fi

      - name: Check all conditions for auto-merge
        id: check
        if: fromJSON(steps.pr.outputs.result).should_skip == false
        uses: actions/github-script@v7
        with:
          script: |
            const prData = ${{ steps.pr.outputs.result }};
            const pr_number = prData.number;
            const sha = prData.sha;

            core.info(`Checking PR #${pr_number} at commit ${sha}`);

            // 1. Get all commit statuses (for blossom-ci and other status checks)
            const { data: statuses } = await github.rest.repos.listCommitStatusesForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: sha,
            });

            core.info(`Found ${statuses.length} commit statuses`);

            // Check for blossom-ci status
            const blossomStatus = statuses.find(s => s.context === 'blossom-ci');
            if (!blossomStatus) {
              core.setFailed('blossom-ci status not found');
              return { ready: false, reason: 'blossom-ci status not found' };
            }

            if (blossomStatus.state === 'pending') {
              core.info('blossom-ci is still pending');
              return { ready: false, reason: 'blossom-ci is pending' };
            }

            if (blossomStatus.state !== 'success') {
              core.setFailed(`blossom-ci status is ${blossomStatus.state}`);
              return { ready: false, reason: `blossom-ci is ${blossomStatus.state}` };
            }

            core.info('✅ blossom-ci is success');

            // Check for any failed or error statuses
            const failedStatuses = statuses.filter(s =>
              s.state === 'failure' || s.state === 'error'
            );

            if (failedStatuses.length > 0) {
              const failedContexts = failedStatuses.map(s => s.context).join(', ');
              core.setFailed(`Failed statuses: ${failedContexts}`);
              return { ready: false, reason: `Failed statuses: ${failedContexts}` };
            }

            core.info('✅ No failed commit statuses');

            // 2. Get all check runs
            const { data: checkRuns } = await github.rest.checks.listForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: sha,
            });

            core.info(`Found ${checkRuns.check_runs.length} check runs`);

            // Check for any failed or error check runs
            const failedChecks = checkRuns.check_runs.filter(check =>
              check.conclusion === 'failure' ||
              check.conclusion === 'cancelled' ||
              check.conclusion === 'timed_out' ||
              check.status !== 'completed'
            );

            if (failedChecks.length > 0) {
              const failedNames = failedChecks.map(c => `${c.name} (${c.conclusion || c.status})`).join(', ');
              core.setFailed(`Failed or incomplete checks: ${failedNames}`);
              return { ready: false, reason: `Failed checks: ${failedNames}` };
            }

            core.info('✅ All check runs passed');

            // 3. Get combined status (this checks required checks)
            const { data: combinedStatus } = await github.rest.repos.getCombinedStatusForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: sha,
            });

            core.info(`Combined status state: ${combinedStatus.state}`);

            if (combinedStatus.state !== 'success') {
              core.setFailed(`Combined status is ${combinedStatus.state}`);
              return { ready: false, reason: `Combined status: ${combinedStatus.state}` };
            }

            core.info('✅ Combined status is success');

            // 4. Check if PR is mergeable (includes branch protection rules like approvals)
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr_number,
            });

            if (pr.mergeable === false) {
              core.setFailed('PR is not mergeable (conflicts or other issues)');
              return { ready: false, reason: 'PR has merge conflicts' };
            }

            if (pr.mergeable_state !== 'clean' && pr.mergeable_state !== 'unstable') {
              core.info(`PR mergeable_state: ${pr.mergeable_state}`);
              // 'blocked' means branch protection rules aren't satisfied
              // 'behind' means needs to be updated
              // 'dirty' means has conflicts
              core.setFailed(`PR mergeable_state is ${pr.mergeable_state}`);
              return { ready: false, reason: `PR mergeable_state: ${pr.mergeable_state}` };
            }

            core.info('✅ PR is mergeable');

            // All conditions met!
            return {
              ready: true,
              pr_number: pr_number,
              reason: 'All conditions met'
            };

      - name: Merge PR
        if: fromJSON(steps.check.outputs.result).ready == true
        uses: actions/github-script@v7
        with:
          script: |
            const checkResult = ${{ steps.check.outputs.result }};
            const pr_number = checkResult.pr_number;

            core.info(`All conditions met. Merging PR #${pr_number}`);

            try {
              await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr_number,
                merge_method: 'squash',
              });

              core.info(`✅ Successfully merged PR #${pr_number}`);

              // Add a comment to indicate auto-merge was successful
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr_number,
                body: '✅ Auto-merged: All CI checks passed and PR requirements met.',
              });
            } catch (error) {
              core.setFailed(`Failed to merge PR: ${error.message}`);
            }
