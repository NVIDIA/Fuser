from enum import Enum, auto
from typing import List, Union, Optional

import torch


def compute_contiguity(sizes, strides) -> List[bool]: ...


class Scalar: ...
class Tensor:
    @property
    def ndim(self) -> int: ...
class Vector:
    @property
    def size(self) -> int: ...


class DataType(Enum):
    Double = auto()
    Float = auto()
    Half = auto()
    Int = auto()
    Int32 = auto()
    Bool = auto()
    BFloat16 = auto()
    ComplexFloat = auto()
    ComplexDouble = auto()
    Null = auto()


class FusionDefinition:
    def __init__(
        self,
        id: Optional[int] = None,
        max_length: int = 1024,
    ) -> None: ...
    def execute(
        self,
        inputs: List[Union[Tensor, Scalar]],
        *,
        device: Optional[Union[int, str, torch.device]] = None,
        override_user_schedule: bool = False,
        capture_debug_output: bool = False,
    ) -> List[Tensor]: ...
    def id(self) -> Optional[int]: ...
    def add_output(self, output: Scalar) -> None: ...
    def add_output(self, output: Tensor, stride_order: List[int]) -> None: ...
    def define_tensor(
        self,
        shape: List[int],
        contiguity: List[bool],
        dtype: DataType = DataType.Float,
        is_cpu: bool = False,
        stride_order: List[int] = [],
    ) -> Tensor: ...
    def define_tensor(
        self,
        shape: List[int],
        contiguity: List[bool],
        dtype: DataType = DataType.Float,
        is_cpu: bool = False,
    ) -> Tensor: ...
    def define_scalar(self, dtype: DataType = DataType.Double) -> Scalar: ...
    def define_scalar(self, value, dtype: DataType) -> Scalar: ...
    def define_constant(self, value, dtype: Optional[DataType]) -> Scalar: ...
    def define_vector(self, size: int) -> Vector: ...
    def define_vector(self, values: Union[List, Tuple], dtype: DataType = DataType::Int) -> Vector:...

    class Operators:
        def __init__(self, fd: FusionDefinition) -> None: ...

        # Unary
        # # Tensor input
        def abs(self, input: Tensor) -> Tensor: ...
        def acos(self, input: Tensor) -> Tensor: ...
        def acosh(self, input: Tensor) -> Tensor: ...
        def asin(self, input: Tensor) -> Tensor: ...
        def asinh(self, input: Tensor) -> Tensor: ...
        def atan(self, input: Tensor) -> Tensor: ...
        def atanh(self, input: Tensor) -> Tensor: ...
        def ceil(self, input: Tensor) -> Tensor: ...
        def cos(self, input: Tensor) -> Tensor: ...
        def cosh(self, input: Tensor) -> Tensor: ...
        def exp(self, input: Tensor) -> Tensor: ...
        def exp2(self, input: Tensor) -> Tensor: ...
        def expm1(self, input: Tensor) -> Tensor: ...
        def erf(self, input: Tensor) -> Tensor: ...
        def erfc(self, input: Tensor) -> Tensor: ...
        def erfinv(self, input: Tensor) -> Tensor: ...
        def erfcinv(self, input: Tensor) -> Tensor: ...
        def floor(self, input: Tensor) -> Tensor: ...
        def frac(self, input: Tensor) -> Tensor: ...
        def lgamma(self, input: Tensor) -> Tensor: ...
        def log(self, input: Tensor) -> Tensor: ...
        def log10(self, input: Tensor) -> Tensor: ...
        def log1p(self, input: Tensor) -> Tensor: ...
        def log2(self, input: Tensor) -> Tensor: ...
        def neg(self, input: Tensor) -> Tensor: ...
        def logical_not(self, input: Tensor) -> Tensor: ...
        def bitwise_not(self, input: Tensor) -> Tensor: ...
        def relu(self, input: Tensor) -> Tensor: ...
        def rand_like(self, input: Tensor) -> Tensor: ...
        def randn_like(self, input: Tensor) -> Tensor: ...
        def reciprocal(self, input: Tensor) -> Tensor: ...
        def round(self, input: Tensor) -> Tensor: ...
        def rsqrt(self, input: Tensor) -> Tensor: ...
        def set(self, input: Tensor) -> Tensor: ...
        def segment_set(self, input: Tensor) -> Tensor: ...
        def sign(self, input: Tensor) -> Tensor: ...
        def sigmoid(self, input: Tensor) -> Tensor: ...
        def signbit(self, input: Tensor) -> Tensor: ...
        def silu(self, input: Tensor) -> Tensor: ...
        def sin(self, input: Tensor) -> Tensor: ...
        def sinh(self, input: Tensor) -> Tensor: ...
        def sqrt(self, input: Tensor) -> Tensor: ...
        def tan(self, input: Tensor) -> Tensor: ...
        def tanh(self, input: Tensor) -> Tensor: ...
        def trunc(self, input: Tensor) -> Tensor: ...
        def isfinite(self, input: Tensor) -> Tensor: ...
        def isinf(self, input: Tensor) -> Tensor: ...
        def isnan(self, input: Tensor) -> Tensor: ...
        def isneginf(self, input: Tensor) -> Tensor: ...
        def isposinf(self, input: Tensor) -> Tensor: ...
        def isreal(self, input: Tensor) -> Tensor: ...
        def real(self, input: Tensor) -> Tensor: ...
        def imag(self, input: Tensor) -> Tensor: ...

        # # Scalar input
        def abs(self, input: Scalar) -> Scalar: ...
        def acos(self, input: Scalar) -> Scalar: ...
        def acosh(self, input: Scalar) -> Scalar: ...
        def asin(self, input: Scalar) -> Scalar: ...
        def asinh(self, input: Scalar) -> Scalar: ...
        def atan(self, input: Scalar) -> Scalar: ...
        def atanh(self, input: Scalar) -> Scalar: ...
        def ceil(self, input: Scalar) -> Scalar: ...
        def cos(self, input: Scalar) -> Scalar: ...
        def cosh(self, input: Scalar) -> Scalar: ...
        def exp(self, input: Scalar) -> Scalar: ...
        def exp2(self, input: Scalar) -> Scalar: ...
        def expm1(self, input: Scalar) -> Scalar: ...
        def erf(self, input: Scalar) -> Scalar: ...
        def erfc(self, input: Scalar) -> Scalar: ...
        def erfinv(self, input: Scalar) -> Scalar: ...
        def erfcinv(self, input: Scalar) -> Scalar: ...
        def floor(self, input: Scalar) -> Scalar: ...
        def frac(self, input: Scalar) -> Scalar: ...
        def lgamma(self, input: Scalar) -> Scalar: ...
        def log(self, input: Scalar) -> Scalar: ...
        def log10(self, input: Scalar) -> Scalar: ...
        def log1p(self, input: Scalar) -> Scalar: ...
        def log2(self, input: Scalar) -> Scalar: ...
        def neg(self, input: Scalar) -> Scalar: ...
        def logical_not(self, input: Scalar) -> Scalar: ...
        def bitwise_not(self, input: Scalar) -> Scalar: ...
        def relu(self, input: Scalar) -> Scalar: ...
        def rand_like(self, input: Scalar) -> Scalar: ...
        def randn_like(self, input: Scalar) -> Scalar: ...
        def reciprocal(self, input: Scalar) -> Scalar: ...
        def round(self, input: Scalar) -> Scalar: ...
        def rsqrt(self, input: Scalar) -> Scalar: ...
        def set(self, input: Scalar) -> Scalar: ...
        def segment_set(self, input: Scalar) -> Scalar: ...
        def sign(self, input: Scalar) -> Scalar: ...
        def sigmoid(self, input: Scalar) -> Scalar: ...
        def signbit(self, input: Scalar) -> Scalar: ...
        def silu(self, input: Scalar) -> Scalar: ...
        def sin(self, input: Scalar) -> Scalar: ...
        def sinh(self, input: Scalar) -> Scalar: ...
        def sqrt(self, input: Scalar) -> Scalar: ...
        def tan(self, input: Scalar) -> Scalar: ...
        def tanh(self, input: Scalar) -> Scalar: ...
        def trunc(self, input: Scalar) -> Scalar: ...
        def isfinite(self, input: Scalar) -> Scalar: ...
        def isinf(self, input: Scalar) -> Scalar: ...
        def isnan(self, input: Scalar) -> Scalar: ...
        def isneginf(self, input: Scalar) -> Scalar: ...
        def isposinf(self, input: Scalar) -> Scalar: ...
        def isreal(self, input: Scalar) -> Scalar: ...
        def real(self, input: Scalar) -> Scalar: ...
        def imag(self, input: Scalar) -> Scalar: ...

        def stride_order(self, arg: Tensor, stride_order: list[int]) -> Tensor: ...

        def rand_like(self, input: Tensor, rng_seed: Scalar, rng_offset: Scalar) -> Tensor: ...
        def randn_like(self, input: Tensor, rng_seed: Scalar, rng_offset: Scalar) -> Tensor: ...

        def abs(self, input: Tensor) -> Tensor: ...
        def neg(self, input: Tensor) -> Tensor: ...

        def _matmul_nn(self, arg1: Tensor, arg2: Tensor) -> Tensor: ...
        def _matmul_nt(self, arg1: Tensor, arg2: Tensor) -> Tensor: ...
        def _matmul_tn(self, arg1: Tensor, arg2: Tensor) -> Tensor: ...
        def _matmul_tt(self, arg1: Tensor, arg2: Tensor) -> Tensor: ...

        def add(self, arg1: Union[Scalar, Tensor], arg2: Union[Scalar, Tensor]) -> Union[Scalar, Tensor]: ...
        def atan2(self, arg1: Union[Scalar, Tensor], arg2: Union[Scalar, Tensor]) -> Union[Scalar, Tensor]: ...
        def div(self, arg1: Union[Scalar, Tensor], arg2: Union[Scalar, Tensor]) -> Union[Scalar, Tensor]: ...
        def truediv(self, arg1: Union[Scalar, Tensor], arg2: Union[Scalar, Tensor]) -> Union[Scalar, Tensor]: ...
        def fmod(self, arg1: Union[Scalar, Tensor], arg2: Union[Scalar, Tensor]) -> Union[Scalar, Tensor]: ...
        def mul(self, arg1: Union[Scalar, Tensor], arg2: Union[Scalar, Tensor]) -> Union[Scalar, Tensor]: ...
        def nextafter(self, arg1: Union[Scalar, Tensor], arg2: Union[Scalar, Tensor]) -> Union[Scalar, Tensor]: ...
        def pow(self, arg1: Union[Scalar, Tensor], arg2: Union[Scalar, Tensor]) -> Union[Scalar, Tensor]: ...
        def remainder(self, arg1: Union[Scalar, Tensor], arg2: Union[Scalar, Tensor]) -> Union[Scalar, Tensor]: ...
        def sub(self, arg1: Union[Scalar, Tensor], arg2: Union[Scalar, Tensor]) -> Union[Scalar, Tensor]: ...
        def mod(self, arg1: Union[Scalar, Tensor], arg2: Union[Scalar, Tensor]) -> Union[Scalar, Tensor]: ...
        def eq(self, arg1: Union[Scalar, Tensor], arg2: Union[Scalar, Tensor]) -> Union[Scalar, Tensor]: ...
        def ge(self, arg1: Union[Scalar, Tensor], arg2: Union[Scalar, Tensor]) -> Union[Scalar, Tensor]: ...
        def gt(self, arg1: Union[Scalar, Tensor], arg2: Union[Scalar, Tensor]) -> Union[Scalar, Tensor]: ...
        def le(self, arg1: Union[Scalar, Tensor], arg2: Union[Scalar, Tensor]) -> Union[Scalar, Tensor]: ...
        def lt(self, arg1: Union[Scalar, Tensor], arg2: Union[Scalar, Tensor]) -> Union[Scalar, Tensor]: ...
        def ne(self, arg1: Union[Scalar, Tensor], arg2: Union[Scalar, Tensor]) -> Union[Scalar, Tensor]: ...
        def logical_and(self, arg1: Union[Scalar, Tensor], arg2: Union[Scalar, Tensor]) -> Union[Scalar, Tensor]: ...
        def logical_or(self, arg1: Union[Scalar, Tensor], arg2: Union[Scalar, Tensor]) -> Union[Scalar, Tensor]: ...
        def bitwise_and(self, arg1: Union[Scalar, Tensor], arg2: Union[Scalar, Tensor]) -> Union[Scalar, Tensor]: ...
        def bitwise_or(self, arg1: Union[Scalar, Tensor], arg2: Union[Scalar, Tensor]) -> Union[Scalar, Tensor]: ...
        def bitwise_xor(self, arg1: Union[Scalar, Tensor], arg2: Union[Scalar, Tensor]) -> Union[Scalar, Tensor]: ...
        def bitwise_left_shit(self, arg1: Union[Scalar, Tensor], arg2: Union[Scalar, Tensor]) -> Union[Scalar, Tensor]: ...
        def bitwise_right_shit(self, arg1: Union[Scalar, Tensor], arg2: Union[Scalar, Tensor]) -> Union[Scalar, Tensor]: ...
        def logical_right_shift(self, arg1: Union[Scalar, Tensor], arg2: Union[Scalar, Tensor]) -> Union[Scalar, Tensor]: ...
        def gcd(self, arg1: Union[Scalar, Tensor], arg2: Union[Scalar, Tensor]) -> Union[Scalar, Tensor]: ...

        def add_alpha(self, arg1: Union[Scalar, Tensor], arg2: Union[Scalar, Tensor], arg3: Scalar) -> Union[Scalar, Tensor]: ...
        def sub_alpha(self, arg1: Union[Scalar, Tensor], arg2: Union[Scalar, Tensor], arg3: Scalar) -> Union[Scalar, Tensor]: ...

        def lerp(self, arg1: Union[Scalar, Tensor], arg2: Union[Scalar, Tensor], arg3: Union[Scalar, Tensor]) -> Union[Scalar, Tensor]: ...
        def where(self, arg1: Union[Scalar, Tensor], arg2: Union[Scalar, Tensor], arg3: Union[Scalar, Tensor]) -> Union[Scalar, Tensor]: ...

        def clamp(self, arg1: Union[Scalar, Tensor], arg2: Scalar, arg3: Union[Scalar, Tensor]) -> Tensor: ...
        def threshold(self, arg1: Union[Scalar, Tensor], arg2: Scalar, arg3: Scalar) -> Scalar: ...

        def addcmul(self, arg1: Union[Scalar, Tensor], arg2: Union[Scalar, Tensor], arg3: Union[Scalar, Tensor], arg4: Union[Scalar, Tensor]) -> Union[Scalar, Tensor]: ...

        def max(self, arg: Tensor, dtype: DataType) -> Tensor: ...
        def max(self, arg: Tensor, axis: int, keepdim: bool, dtype: DataType) -> Tensor: ...
        def max(self, arg: Tensor, axis: List[int], keepdim: bool, dtype: DataType) -> Tensor: ...
        def min(self, arg: Tensor, dtype: DataType) -> Tensor: ...
        def min(self, arg: Tensor, axis: int, keepdim: bool, dtype: DataType) -> Tensor: ...
        def min(self, arg: Tensor, axis: List[int], keepdim: bool, dtype: DataType) -> Tensor: ...
        def prod(self, arg: Tensor, dtype: DataType) -> Tensor: ...
        def prod(self, arg: Tensor, axis: int, keepdim: bool, dtype: DataType) -> Tensor: ...
        def prod(self, arg: Tensor, axis: List[int], keepdim: bool, dtype: DataType) -> Tensor: ...
        def sum(self, arg: Tensor, dtype: DataType) -> Tensor: ...
        def sum(self, arg: Tensor, axis: int, keepdim: bool, dtype: DataType) -> Tensor: ...
        def sum(self, arg: Tensor, axis: List[int], keepdim: bool, dtype: DataType) -> Tensor: ...

        def cast(self, arg: Tensor, dtype: DataType) -> Tensor: ...

        def batch_norm(
            self,
            arg: Tensor,
            weight: Optional[Tensor],
            bias: Optional[Tensor],
            running_mean: Optional[Tensor],
            running_var: Optional[Tensor],
            momentum: Scalar,
            eps: Scalar,
            training: bool,
            channels_last: bool,
        ) -> Tensor: ...

        def broadcast_in_dim(
            self,
            arg: Tensor,
            shape: Union[Tuple, List],
            broadcast_dims: List[int],
        ) -> Tensor: ...

        def broadcast(self, arg: Tensor, is_broadcast_dim: List[bool]) -> Tensor: ...

        def cat(self, tensors: List[Tensor], dim: int) -> Tensor: ...

        def index_select(self, arg: Tensor, index: Tensor, dim: int) -> Tensor: ...

        def gather(self, arg1: Tensor, index: Tensor, dim: int) -> Tensor: ...

        def pad(self, arg: Tensor, pad_widths: List[int], value: Optional[Scalar]) -> Tensor: ...

        def take_along_axis(self, arg1: Tensor, index: Tensor, dim: int) -> Tensor: ...

        def permute(self, arg: Tensor, dims: List[int]) -> Tensor: ...

        def slice(self, arg: Tensor, start_indices: List[int], end_indices: List[int]) -> Tensor: ...

        def squeeze(self, arg: Tensor, original_shape: List[int], dims: List[int]) -> Tensor: ...

        def tensor_sizes(self, arg: Tensor) -> List[Scalar]: ...

        def reshape(self, arg: Tensor, new_shape: Union[List, Tuple]) -> Tensor: ...

        def full(self, shape: List[int], fill_value: Scalar, dtype: DataType) -> Tensor: ...

        def iota(self, length: Scalar, start: Optional[Scalar], step: Optional[Scalar], dtype: DataType) -> Tensor: ...

        def var(self, arg: Tensor, axes: List[int], correction: int, keepdim: bool) -> Tensor: ...
        def var_mean(self, arg: Tensor, axes: List[int], correction: int, keepdim: bool) -> Tuple[Tensor, Tensor]: ...

        def uniform(self, minval: Scalar, maxval: Scalar, shape: List[Scalar], dtype: DataType, rng_seed: Optional[Scalar], rng_offset: Optional[Scalar]) -> Tensor: ...
        def normal(self, mean: Scalar, std: Scalar, shape: List[Scalar], dtype: DataType, rng_seed: Optional[Scalar], rng_offset: Optional[Scalar]) -> Tensor: ...

    ops: Operators
